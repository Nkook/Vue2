{"version":3,"file":"vue.js","sources":["../src/observe/array.js","../src/observe/dep.js","../src/observe/index.js","../src/state.js","../src/compiler/parse.js","../src/compiler/index.js","../src/observe/watcher.js","../src/vdom/index.js","../src/lifecycle.js","../src/init.js","../src/index.js"],"sourcesContent":["// 重写数组中的部分方法，最后把重写的对象返回出去\n\n// 1. 首先拿到原来的数组的方法，通过原型\nlet oldArrayProto = Array.prototype\n\n// 2. 不能直接修改原来的，需要扩展出来一份。生成一份新的数组方法\n// newArrayProto.__proto__ = oldArrayProto\nexport let newArrayProto = Object.create(oldArrayProto) // Object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。\n\n\n// 找到所有的变异方法，就是能修改原数组的方法\nlet methods = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'reverse',\n    'sort',\n    'splice'\n] // concat slice都不会改变原数组\n\n// 3. 重写这个方法\nmethods.forEach(method => {\n    // arr.push(1, 2, 3)\n    newArrayProto[method] = function(...args) { // 这里重写了数组的方法\n        // push.call(arr)\n        // todo...\n        const result = oldArrayProto[method].call(this, ...args) // 内部调用原来的方法，函数的劫持，叫做切片编程。这里的this谁调用方法push就指向谁，arr.push调用就指向arr\n        \n        console.log('method', method)\n        // 5. 拿到实例上的observeArray方法: 这里的this指的是调用方法的，data调用的，指向data,从data上获取属性__ob__，这个属性指向Observer的实例，拿到实例对象，就可以用它身上的observeArray方法\n        let ob = this.__ob__\n        // 4. 需要对新增的 数据再次进行劫持\n        let inserted\n        switch (method) {\n            case 'push':\n            case 'unshift': // arr.unshift(1, 2, 3)\n                inserted = args\n                break;\n            case 'splice': // arr.splice(0, 1, {a: 1}, {b: 2})\n                inserted = args.slice(2) // 截取从索引2开始往后的数据\n            default:\n                break;\n        }\n\n        console.log(inserted) // 新增的内容\n        if (inserted) {\n            // 6. 对新增的内容再次进行观测：如何观测？还是通过前面的observeArray去观测，但是这里是拿不到observeArray的，\n            // 只能拿到this，this指的是调用方法的对象，谁调用这些方法，this就是谁。在index.js可以看到data.__proto__ = newArrayProto，是data调用的这些方法，那么this指的就是data\n            ob.observeArray(inserted)\n\n        }\n\n\n\n        return result\n    }\n})\n","// 首次渲染的时候会收集， 更新的时候会再次收集。\n// 只有在模板里取值的时候，才会做依赖收集。\n\nlet id = 0;\n// 8-1. 每个属性都有dep，创建一个类\nclass Dep{\n    constructor(){\n        this.id = id++; // 属性的dep要收集watcher；每次执行id就++\n        this.subs = [];// 这里存放着当前属性对应的watcher有哪些; 一个属性可能有多个watcher（一个属性可以在a组件用，b组件用...）；\n        // 8-3 \n        // 此时再去boserve/index.js中给每个属性增加dep，let dep = new Dep()\n        // 有了dep也有了watcher，如何让他俩关联起来？可以把当前的watcher暴漏在全局上；Dep.target = null;\n        // 在watcher.js中把当前的watcher赋值给全局变量Dep.target\n    }\n    // 8-5\n    depend(){\n        // 这里我们不希望放重复的watcher，而且刚才只是一个单向的关系 dep收集-> watcher；也希望 watcher记录 ->dep\n        // watcher 记录dep\n        // this.subs.push(Dep.target); // 把当前的watcher放入这个栈中。这样存在重复\n\n        Dep.target.addDep(this); // 让当前watcher（Dep.target）记住dep。 在watcher.js中实现这个方法。\n\n        // 8-7\n        // dep 和 watcher是一个多对多的关系 （一个属性可以在多个组件中使用 dep -> 多个watcher）\n        // 一个组件中由多个属性组成 （一个watcher 对应多个dep）\n    }\n    // 8-6\n    addSub(watcher){\n        this.subs.push(watcher) // 将watcher放入subs\n    }\n    // 8-8\n    notify(){\n        this.subs.forEach(watcher=>watcher.update()); // 告诉watcher要更新了，让这里subs所有记住的依赖都调用更新方法\n    }\n}\n// 8-4\nDep.target = null; // 可以把当前的watcher暴漏在全局上\n\n// 8-2. 导出\nexport default Dep;\n","import { newArrayProto } from './array'\nimport Dep from './dep'\n\nexport function observe(data) {\n    // 对data这个对象进行劫持\n    // 5-1 判断是否是对象 // 只对对象进行劫持\n    if (typeof data !== 'object' || data == null) {\n        return\n    }\n    // 6-5 如果data上有个属性叫__ob__，它是类Observer的实例，说明这个对象被监测过了，直接把实例返回，不需要再观测了\n    if (data.__ob__ instanceof Observer) {\n        return data.__ob__\n    }\n\n    // 5-2 如果一个对象被劫持过了，那就不需要再被劫持了（要判断一个对象是否被劫持过，可以增添一个实例，用实例来判断是否被劫持过）\n    // 在内部又创建了一个类，这个类专门去观测数据的。如果这个数据被观测过，那么它的实例就是这个类\n    // 对data这个数据进行观测\n    return new Observer(data)\n\n}\n\n// 5-3\nclass Observer {\n    constructor(data) {\n        // 6-6 如果data是个对象的话，也会加一个__ob__属性，然后进入else中，去遍历每一项，遍历到__ob__发现是个对象；会再次进入到Observer中，再添加个_ob__这样就形成了死循环。？？？？【这里理解不透彻】\n        // 不能让data作为对象循环的时候遍历到这个__ob__属性，把它变成不可枚举类型，就可以了\n        Object.defineProperty(data, '__ob__', {\n            value: this,\n            enumerable: false // 将__ob__变成不可枚举（循环的时候无法获取到）\n        })\n        // // 6-4 // 在data上加一个自定义属性__ob__ 把this放上去，把，this指的是Observer的实例对象\n        // data.__ob__ = this  // 给数据加了一个标识，如果数据上有__ob__则说明这个属性被观测过了\n        // 6-1 对象可以遍历，数组有很多个，遍历会造成性能差。如果是数组，\n        if (Array.isArray(data)) {\n            // 6-3 这里可以重写数组中的方法 7个变异方法，是可以修改数组本身的。\n            data.__proto__ = newArrayProto // 需要保留数组原有的特性，并且可以重写部分方法\n            this.observeArray(data) // 如果数组中放的是对象，可以监控到对象的变化。\n        } else {\n            // 5-3 对这个数据的每个属性都劫持\n            // Object.defineProperty只能劫持已经存在的属性，后增的、或删除的是不知道的。（vue2里会为此单独写一些api $set $delete）\n            // 遍历这个对象\n            this.walk(data)\n        }\n    }\n\n    // 5-3 遍历对象进行观测\n    walk(data) { // 循环对象，重新定义属性，对属性依次劫持\n        // 重新定义属性 （性能差，相当于把属性重写了）\n        // defineReactive方法 把data这个数据定义成响应式的，属性是当前的key，值是当前的data[key]。这个方法没写在类里，写在外面可以导出，其他地方也可以使用。\n        Object.keys(data).forEach(key => defineReactive(data, key, data[key]))\n    }\n    // 6-2 遍历数组进行观测\n    observeArray(data) {\n        data.forEach(item => observe(item)) // 如果数组中存在引用类型，则劫持该项中的每一个属性\n    }\n}\n\n// 5-4\nexport function defineReactive(target, key, value) { // 属性劫持。闭包，里面的函数使用外面的value，这个变量不能被销毁\n    // 5-8 深度属性劫持。针对某个属性值还是个对象\n    observe(value) // 对所有的对象都进行属性劫持。\n    // 在第10节课：lifecycle.js给每个属性增加dep: 有了dep也有了watcher，如何让他俩关联起来\n    // 10-1\n    let dep = new Dep()\n    // 5-4\n    Object.defineProperty(target, key, {\n        get() { // 取值的时候会执行get\n            console.log('用户取值了')\n            // 10-2 属性的dep收集watcher\n            if(Dep.target){\n                dep.depend(); // 让这个属性的收集器记住当前的watcher；去dep.js中增加个方法depend\n            }\n            return value\n        },\n        set(newValue) { // 修改的时候会执行set\n            console.log('用户设置值了')\n            if (newValue === value) return\n            observe(newValue) // 5-9 如果修改值的时候直接赋值个对象，对这个对象里的每个属性进行劫持\n            value = newValue\n            // 10-3 属性更新 让dep去更新视图\n            dep.notify() // 通知更新\n        }\n    })\n\n}\n","import { observe } from \"./observe/index\"\n\nexport function initState(vm) {\n    const opts = vm.$options // 获取所有的选项\n    // 3. 如果选项中有data属性，则做数据初始化\n    if (opts.data) {\n        initData(vm)\n    }\n}\n// 4. 数据初始化\nfunction initData(vm) {\n    let data = vm.$options.data // data可能是函数和对象\n    data = typeof data === 'function' ? data.call(vm) : data // data是用户返回的对象\n    console.log(data)\n\n    // 5-5\n    // 把对象放在了实例上，并对这个对象进行了观测。此时去打印vm，会发现有个_data属性下面有name和age及其对应的get和set；但是取值需要通过vm._data.name取，无法直接通过vm.name取值\n    vm._data = data // 我将返回的对象放到了_data上\n\n    // 5. 对数据进行劫持\n    // vue2采用了一个api defineProperty\n    // 提供一个方法observe 去观测data数据: 响应式模块\n    observe(data)\n\n    // 5-6 想通过vm.xxx直接取值，需要将vm_data 用vm来代理就可以了。自己定义个方法\n    for(let key in data) {\n        proxy(vm, '_data', key) // 代理实例vm上的某个属性key叫_data。其实就是代理_data这个属性\n    }\n\n}\n\n// 5-7\nfunction proxy(vm, target, key) {\n    // 给vm对象，添加一个属性key，并给每个属性增加存取描述符属性\n    Object.defineProperty(vm, key, { // vm.name\n        get() {\n            return vm[target][key]   // vm._data.name\n        },\n        set(newValue) {\n            vm[target][key] = newValue\n        }\n    })\n}\n\n// 到这里就有两次数据劫持，一次是把用户的数据进行了属性劫持，一次是代理，当取值的时候代理到了某个值","// <div id=\"app\">\n//    <div>{{name}}</div>\n//    <span>{{age}}</span>\n// </div>\n// 3. vue2采用正则 匹配标签 属性 表达式\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 匹配标签名<div></div>\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 匹配到的分组是一个 标签名  <xxx 匹配到的是开始 标签的名字\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`);  // 匹配的是</xxxx>  最终匹配到的分组就是结束标签的名字\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;  // 匹配属性 a = \"123\"\n// 第一个分组就是属性的key value就是分组3/分组4/分组5\nconst startTagClose = /^\\s*(\\/?)>/;  // 匹配结束标签 </div> <br/>\n// const defaultTagRE = /\\{((?:.|\\r?\\n)+?)\\}\\}/g  // 匹配到的内容就是表达式的变量{{aa}}\n\n// vue3 采用的不是使用正则\n\n// 对模版进行编译处理\n// 1-1\nexport function parseHTML(html) { // html最开始肯定是一个 <div   <div>hello</div>\n    //  1-13 最终需要转化成一颗抽象语法树，需要构建父子关系。\n    // 栈型结构，栈中的最后一个元素是当前匹配到开始标签的父亲。匹配到<div>放入栈；匹配到<div>放进栈，匹配到</div>结束标签时，再把<div>扔出去；匹配到<span>放入，匹配到</span>移除....\n    const ELEMENT_TYPE = 1; // 元素类型为1\n    const TEXT_TYPE = 3;    // 文本类型为3\n    const stack = []; // 用于存放元素的栈\n    let currentParent; // 指向的是栈中的最后一个\n    let root; // 是否是根节点\n\n    // 最终需要转化成一颗抽象语法树：一个节点包含标签名称、类型、子元素、属性、父元素\n    function createASTElement(tag, attrs) {\n        return {\n            tag,\n            type: ELEMENT_TYPE,\n            children: [],\n            attrs,\n            parent: null\n        }\n    }\n    //  1-11 现在只是把标签文本删掉了，并没有做任何处理替换。对这些进行处理，需要这几个方法暴漏出去，在解析到开始标签、文本、结束标签的时候进行替换。\n    // 1-11-1遇到开始节点创建节点，没有根节点，就是树根；如果有父节点，那就设置为当前节点的父节点，并把当前节点作为父节点的孩子；将节点放入栈中，更更新为当前父节点\n    // 利用栈型结构 来构造一颗树\n    function start(tag, attrs) {\n        // console.log('开始标签', tag, attrs)\n        let node = createASTElement(tag, attrs) // 创造一个ast节点\n        if (!root) { // 看一下是否空树，如果没有root根节点，那么这个节点就作为树的根节点\n            root = node\n        }\n        if(currentParent){ // 如果当前父节点有值，将当前节点的父亲节点设置为currentParent\n            node.parent = currentParent; // 只赋予了parent属性\n            currentParent.children.push(node); // 还需要让父亲记住自己\n        }\n        stack.push(node) // 将节点放入栈中\n        currentParent = node; // currentParent作为栈中的最后一个节点\n    }\n    // 1-11-2 对于文本直接放入当前父节点的子节点中\n    function chars(text) { // 文本直接放到当前指向的节点中\n        console.log('文本', text, text.length)\n        text = text.replace(/\\s/g,''); // 如果空格超过2就删除2个以上的\n        text && currentParent.children.push({\n            type:TEXT_TYPE,\n            text,\n            parent:currentParent\n        });\n    }\n    // 1-11-3 遇到结束标签，弹出该节点，并将最后一个节点更新为当前父节点\n    function end(tag) {\n        // console.log('结束标签', tag)\n        let node =  stack.pop();  // 遇到结束节点，弹出栈中最后一个。可以通过tag和node对比 校验标签是否合法\n       currentParent = stack[stack.length - 1]; // 更新当前父节点\n    }\n    // 1-4 \n    function advance(n) {\n        html = html.substring(n) // 截取的长度就是匹配到的开始标签的长度 '<div'\n    }\n    // 1-3 解析开始标签 并返回匹配的结果\n    function parseStartTag() {\n        const start = html.match(startTagOpen) // 用html通过正则匹配看是否是开始标签\n        // console.log('start', start) // ['<div', 'div', index: 0, input: '<div id=\"app\">\\n        <div>{{name}}</div>\\n        <span>{{age}}</span>\\n    </div>', groups: undefined]\n        if (start) { // 如果匹配到了就是开始标签：把结果组成一个对象，把标签名、对应的属性放进去\n            const match = {\n                tagName: start[1], // 标签名\n                attrs: [] // 属性\n            }\n            // console.log(match) // {tagName: 'div', attrs: Array(0)}\n            // 1-4 需要对html不停的解析，已经解析过的要删除掉。比如，解析了开始标签，把<div>删除掉，再解析 id='app'属性。所以要有个删除的过程，写个方法，叫前进，前进长度就是匹配到的内容的总长度\n            advance(start[0].length);\n            // console.log(start[0], html) // 打印可以看到匹配一段就少一段 <div   id=\"app\"><div>{{name}}</div><span>{{age}}</span></div>\n            \n            // 1-5 匹配属性：只要不是开始标签的结束!html.match(startTagClose，就一直匹配下去；拿到每次匹配的属性html.match(attribute)放到数组attr中。删除掉匹配的属性\n            let attr, end\n            while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n                advance(attr[0].length); // id=\"app\"就删掉了\n                // 1-6 需要把属性解析出来放到attrs属性中去\n                match.attrs.push({ name: attr[1], value: attr[3] || attr[4] || attr[5] || true })\n            }\n            // 也应该把结束标签>删掉, 如果end有值就删除\n            if (end) {\n                advance(end[0].length);\n            }\n            return match\n            // 1-6\n            // console.log(match) // {tagName: 'div', attrs: [{name: 'id', value: 'app'}]}\n        }\n\n        // 否则不是开始标签\n        return false\n    }\n    // debugger 可以看整个过程\n    // 1-2 整个过程：遇到开始标签解析开始标签，遇到文本解析文本，遇到结束标签解析结束标签\n    while(html) { // 每解析一个标签就把它从这个字符串中删除掉，整个模版字符串都没有了就解析完了 // while : 在…. 期间， 所以 while循环 就是在满足条件期间，重复执行某些代码。 continue：结束本次循环，继续下次循环。break：跳出所在的循环\n        // 如果textEnd 为0 说明是一个开始标签或者结束标签 如： <div>hello</div>\n        // 如果textEnd > 0说明就是文本的结束位置\n        let textEnd = html.indexOf('<') // 如果indexof中的索引是0 则说明是个标签\n        // 1-2 解析标签\n        if (textEnd == 0) {\n            // 1-3\n            const startTagMatch = parseStartTag() // 解析开始标签 // 开始标签的匹配结果: 先匹配开始标签，再匹配属性，再匹配结束标签；并把已经匹配到的从html模版字符中删除掉；返回匹配到的结果对象{tagName: 标签名, attrs: 属性}\n            // 1-7 如果是【开始标签】有值，跳过本轮操作，继续再往下走\n            if (startTagMatch) { // 解析到的开始标签\n                // 1-12\n                start(startTagMatch.tagName, startTagMatch.attrs)\n                // console.log(html) // 这个时候看到还是开始标签 <div>{{name}}</div><span>{{age}}</span></div>\n                continue // 为啥跳出本次循环，因为开始标签移除后，再重新循环html去找结束标签就好了。下面的代码就不再走了，如果不写，就走到下面解析文本了\n            }\n            \n            // 1-9 如果不是开始标签，就是【结束标签】。匹配到后直接删除\n            let endTagMatch = html.match(endTag); // 通过正则匹配结束标签，返回当前结束标签的名字\n            if (endTagMatch) { // 如果有值就删除掉\n                advance(endTagMatch[0].length);\n                // 1-12\n                end(endTagMatch[1])\n                continue;\n            }\n        }\n        // 1-8 解析【文本】内容\n        if (textEnd > 0) {\n            let text = html.substring(0, textEnd); // 文本内容\n            if (text) {\n                // 1-12\n                chars(text)\n                advance(text.length); // 解析到的文本 \n            }\n        }\n    }\n    console.log('root', root)\n    return root\n    // console.log(html, '====')\n}","// 将html转成ast语法树\nimport { parseHTML } from \"./parse\";\n\n// 2-6\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; // {{ asdsadsa }}  匹配到的内容就是我们表达式的变量\n\n// 2-2 遍历当前节点属性，把每一项通过字符串进行拼接；遇到style需要用大括号{style:{color:'red'}}\nfunction genProps(attrs) {\n    //attrs属性在ast树上是个数组[{name: 'style', value: 'color: red; background: pink;'}]\n    // 转成 {style:{\"color\":\" red\",\"background\":\" pink\"}}\n    let str = ''// {name: value}\n    for (let i = 0; i < attrs.length; i++) {\n        let attr = attrs[i];\n        if (attr.name === 'style') {\n            // color:red;background:red => {color:'red', background:'red'}\n            let obj = {};\n            attr.value.split(';').forEach(item => { // 先通过分号分割成数组，再循环组成对象\n                let [key, value] = item.split(':');\n                obj[key] = value;\n            });\n            attr.value = obj\n        }\n        str += `${attr.name}:${JSON.stringify(attr.value)},` // [{name: 'id', value: 'app'}] 转成 {id:\"app\"}\n    }\n    return `{${str.slice(0, -1)}}` // 去除最后一个字符逗号\n}\n// 2-5 如果是文本创建文本，如果是标签创建标签\n// _c创建元素， _v创建文本， _s是变量转成字符串\n// 过程：1）先判断是文本还是标签，如果是标签调用codegen方法，拼接tag标签，再拼接该标签的属性，再拼接该节点的孩子\n//      2）如果是文本，分为纯文本和含有{{变量}}的文本; \n//          2.1）通过正则匹配该文本中是否含有变量，如果没有，直接转成字符串拼接；\n//          2.2) 如果存在有变量，分三种情况处理。循环该文本正则匹配到值，并依次放入数组中tokens\n//                  如果匹配到的变量索引 > 最后一个索引值(默认0)，说明两个变量中间存在纯文本，需要通过slice截取出来放入tokens中\n//                  如果匹配到的变量索引为0，将匹配到的变量直接放入tokens中，并将最后索引值更新为 = 当前变量的索引值+当前变量的长度\n//                  如果最后索引值 < text整个文本的总长度，说明后面还有纯文本，通过slice截取后面的字符放入tokens中\nfunction gen(node) {\n    console.log('node', node)\n    if (node.type === 1) { // 标签，需要调用方法 去 拼接tag标签，再拼接该标签的属性，再拼接节点的孩子\n        return codegen(node);\n    } else { // 纯文本，需要分两种情况 {{name}}hello   呵呵\n        let text = node.text  \n        if (!defaultTagRE.test(text)) { // 是否是纯文本，如果是文本 什么都不用做，直接返回这个纯文本字符。defaultTagRE.test('hello') == false   defaultTagRE.test('{{name}}hello') == true\n            return `_v(${JSON.stringify(text)})`\n        } else {\n            //_v( _s(name)+'hello' + _s(age))\n            let tokens = [];\n            let match; // 匹配到的文本\n            defaultTagRE.lastIndex = 0; // 正则里面含有/g的话，exec每次用过之后需要重置位置，否则只能被捕获到一次\n            let lastIndex = 0;\n            // split\n            while (match = defaultTagRE.exec(text)) { // 通过正则匹配到有变量的文本赋值给match。 这里的text是{{name}}hello{{age}}\n                console.log('match', match) //  ['{{name}}', 'name', index: 0, input: '{{name}}hello{{age}}', groups: undefined]  ['{{age}}', 'age', index: 13, input: '{{name}}hello{{age}}', groups: undefined]\n                let index = match.index; // 匹配变量的位置: 比如第一个{{name}}位置是0，第二个{{age}}是13。 {{name}} hello {{age}} hello\n                if (index > lastIndex) { // 匹配的第二个变量的位置比上一次更新的位置大的话，说明两个变量之间存在文本，需要把文本放进去。\n                    tokens.push(JSON.stringify(text.slice(lastIndex, index))) // 截取 最后一次位置到当前第二个变量的位置就是中 纯文本\n                }\n                tokens.push(`_s(${match[1].trim()})`)\n                lastIndex = index + match[0].length // lastIndex等于当前匹配的位置加上当前匹配到变量的长度，就是整个文本最后一次的位置。 {{name}} hello {{age}}第一次index是0，长度是{{name}}8，最后一次位置更新为8\n            }\n            if (lastIndex < text.length) { // 最后匹配的位置小余整个文本的长度，需要把后面的纯文本放入\n                tokens.push(JSON.stringify(text.slice(lastIndex)))\n            }\n            console.log('tokens', tokens) //  ['_s(name)', '\"hello\"', '_s(age)']\n            return `_v(${tokens.join('+')})`\n        }\n    }\n}\n// 2-4 遍历子节点 \nfunction genChildren(children) {\n    return children.map(child => gen(child)).join(',')\n}\n// 2-1\nfunction codegen(ast) {\n    // 2-3 拼接子节点\n    let children = genChildren(ast.children);\n    // 2-1拼接tag标签，再拼接该标签的属性，再拼接节点的孩子\n    // _c('div',{id:\"app\"},_c('div',{style:{\"color\":\" red\",\"background\":\" pink\"}},_v(_s(name)+\"hello\"+_s(age))),_c('span',null,_v(_s(age))))\n    let code = (`_c('${ast.tag}',${ast.attrs.length > 0 ? genProps(ast.attrs) : 'null'\n        }${ast.children.length ? `,${children}` : ''\n        })`)\n\n    return code;\n}\n\n\nexport function compileToFunction(template) {\n    // 1. 将template转化成ast语法树（模版针对的就是上面的内容：对于标签解析的是标签名、文本、表达式、属性、字符串等）\n    let ast = parseHTML(template)\n    console.log(ast)\n    // 2. 将语法树 转成render方法（render方法执行后的返回结果就是 虚拟DOM）\n    // 2-1 \n    let code = codegen(ast) // 拿到的是字符串，想让字符串运行\n    // console.log('code', code) //  _c('div',{id:\"app\"},_c('div',{style:{\"color\":\" red\",\"background\":\" pink\"}},_v(_s(name)+\"hello\"+_s(age))),_c('span',null,_v(_s(age))))\n\n    // 2-7 模板引擎的实现原理 就是 with  + new Function\n    code = `with(this){return ${code}}` // 将编译后的结果包装成with。with为了取值方便，this是谁就从谁身上取值。对象属性直接变成了with作用域下的\n    let render = new Function(code) // 根据字符串生成render函数\n    \n    // console.log(render.toString()) 打印结果如下\n    // function anonymous(\n    //     ) {\n    //     with(this){return _c('div',{id:\"app\"},_c('div',{style:{\"color\":\" red\",\"background\":\" pink\"}},_v(_s(name)+\"hello\"+_s(age))),_c('span',null,_v(_s(age))))}\n    //     }\n    // 通过call改变this指向vm\n    // render.call(vm)\n\n    return render\n\n    // 生成一个函数，叫render函数，参数h，里面需要创建个div，div有自己的属性；还有自己的儿子及其属性；还有个表达式文本内容，表达式可能是对象，先JSON.stringify转成字符串\n    // 创建一个元素_c，\n    // 元素有个儿子叫div,属性叫id: app；有一个儿子叫div属性叫style:{color: 'red'}；儿子里面放的是个变量可能是字符串，先JSON.stringify转正字符串，再拼接hello\n    // 还有一个儿子叫span，没有属性，有个变量叫age\n    // 实现_c  _v  _s方法就可以了。最终把ast树组装成下面这样的语法就结束了\n    // 先不考虑render函数，可以通过new Function 生成函数，先考虑这个返回值。\n    // render() {\n    //     return _c('div',{id:\"app\"},_c('div',{style:{\"color\":\" red\",\"background\":\" pink\"}},_v(_s(name)+\"hello\"+_s(age))),_c('span',null,_v(_s(age))))\n    // }\n    \n}\n\n// let obj = {}\n// with(obj) {\n//     console.log(this.a) // 这里的this就是obj,使用with时，里面的取值都会从obj上取\n// }\n\n// ast树\n// {tag: 'div', type: 1, children: Array(2), attrs: Array(1), parent: null}\n//     attrs: Array(1)\n//         0: {name: 'id', value: 'app'}\n//         length: 1\n//         [[Prototype]]: Array(0)\n//     children: Array(2)\n//         0: {tag: 'div', type: 1, children: Array(1), attrs: Array(1), parent: {…}}\n//         1: {tag: 'span', type: 1, children: Array(1), attrs: Array(0), parent: {…}}\n//         length: 2\n//         [[Prototype]]: Array(0)\n//     parent: null\n//     tag: \"div\"\n//     type: 1\n//     [[Prototype]]: Object\n\n// children\n// children: Array(2)\n//     0:\n//         attrs: Array(1)\n//             0:\n//                 name: \"style\"\n//                 value: {color: ' red', background: ' pink', \"\": undefined}\n//                 [[Prototype]]: Object\n//                 length: 1\n//                 [[Prototype]]: Array(0)\n//         children: Array(1)\n//             0: {type: 3, text: '{{name}}hello{{age}}', parent: {…}}\n//             length: 1\n//             [[Prototype]]: Array(0)\n//         parent: {tag: 'div', type: 1, children: Array(2), attrs: Array(1), parent: null}\n//         tag: \"div\"\n//         type: 1\n//         [[Prototype]]: Object\n//     1: {tag: 'span', type: 1, children: Array(1), attrs: Array(0), parent: {…}}\n//     length: 2\n//     [[Prototype]]: Array(0)\n//     parent: null\n//     tag: \"div\"\n//     type: 1\n//     [[Prototype]]: Object","\n// 10. 整个过程：\n// 1）当我们渲染的时候会创建watcher，我们会把当前的渲染watcher放到全局dep.target上。\n// 2）然后取值调用_render()；取值会走到index.js的get上；    this.getter = fn；fn是vm._update(vm._render())；\n        // 在observe/index.js的 get方法上进行判断，当前属性的dep是否有target，有的话就让这个属性的收集器记住当前的watcher\n\nimport Dep from './dep'\nconsole.log('Dep', Dep)\n\n\n// 1. 需要区分是哪个watcher，每个组件都会有一个watcher，这样某个组件更新只需要更新这个组件的watcher就好。组件的特点：复用，方便维护，局部更新\n// 每次创建一个watcher都给一个唯一的id\nlet id = 0\n\n// 2. 创建一个watcher类（是个渲染的类）\nclass Watcher { // 不同组件有不同的watcher,每个组件都需要去创建一个watcher, 目前只有一个 渲染根实例的\n    // vm是当前watcher是哪个实例，fn要做哪些事（渲染函数)，options是参数 \n    constructor(vm, fn, options) {\n        this.id = id++;\n        // 7. 渲染watcher  // 8. 接着需要给每个属性增加dep创建observe/dep.js\n        this.renderWatcher = options; // 这里做个标识是一个渲染watcher\n        // 4. 把渲染的方法fn封装到了当前watcher中。这个函数是具备取值操作的，因为要渲染到页面上\n        this.getter = fn; // getter意味着调用这个函数可以发生取值操作。fn是vm._update(vm._render())\n        // 11. 收集dep: dep收集watcher的同时，让watcher也记录dep。// 后续我们实现计算属性，和一些清理工作需要用到\n        //      去到dep.js中做处理 Dep.target.addDep(this)，把当前属性的dep传给watcher\n        this.deps = [];\n        // 13. 通过set对重复属性进行去重。如果一个属性在多个地方使用，不需要重复去收集watcher\n        this.depsId = new Set();\n        // 5. 页面初次渲染，如果首次传入进来fn但是不调用的话，那么页面第一次是无法渲染的。\n        this.get();\n    }\n    // 12. 一个组件有多个属性，重复的属性也不用记录。去重\n    // 这里实现了watcher收集dep，dep收集watcher，并进行了去重。\n    addDep(dep) { \n        let id = dep.id;\n        // 14. 这个id不是从0++的吗？那应该每次都不一样啊？？？怎么通过判断是否在这个集合呢？？？\n        if (!this.depsId.has(id)) {\n            this.deps.push(dep); // watcher记住这个dep \n            this.depsId.add(id); // 并将这个塞入depsId中，用于下次判断\n            dep.addSub(this); // dep记住watcher。\n        }\n    }\n    // 6. 首次取值需要调用 this.getter()也就是vm._update(vm._render()) 这个渲染方法\n    get() {\n        // 9. 在dep.js中增加个变量叫target。在执行watcher之前把这个watcher放到全局变量Dep上\n        Dep.target = this // 把当前的watcher赋值给全局变量（类中的this指的都是当前的实例）；\n        this.getter() // 调用_render()会取值，会去vm上取值；取值的时候\n        Dep.target = null // 视图渲染完成后清空\n    }\n    // 15. 更新属性时需要调用更新\n    // 这个watcher就可以理解为观察者，会观察某个属性。\n    // 【每个属性有一个dep（属性就是被观察者），watcher就是观察者（属性变化了会通知观察者来更新），-> 观察者模式】\n    update() {\n        // queueWatcher(this); // 把当前的watcher 暂存起来\n        this.get(); // 属性更新后， 重新渲染\n    }\n}\n\n// 6. 需要让每个属性和watcher关联起来\n/**\n * 需要给每个属性增加一个dep， 目的就是收集watcher\n * 一个组件对应一个watcher，一个组件中有多个属性，多个属性对应一个watcher\n * 一个属性有一个watcher，一个属性存在于多个组件中，一个属性对应多个watcher\n * \n * （变量本身是和watcher没有关联的，想关联需要分配dep，让dep把watcher收集起来）\n * 多对多的关系\n */\n\n// 3. 导出类，在3.index.html中进行 new Watcher并传入实例和回调函数\nexport default Watcher","// 专门用于构建虚拟dom的方法\n\n// 1. h()  _c() 创建元素的虚拟节点\nexport function createElementVNode(vm, tag, data, ...children) {\n    if (data == null) {\n        data = {}\n    }\n    let key = data.key; // 属性的key值\n    if (key) {\n        delete data.key\n    }\n    return vnode(vm, tag, key, data, children); // 虚拟节点上有vm实例，标签，key，属性，孩子\n}\n// 3. _v();  创建文本的虚拟节点\nexport function createTextVNode(vm, text) {\n    return vnode(vm, undefined, undefined, undefined, undefined, text);\n}\n// 和ast一样吗？ ast做的是语法层面的转化 他描述的是语法本身 (可以描述js css html)\n// 2. 我们的虚拟dom 是描述的dom元素，可以增加一些自定义属性  (描述dom的)\n// diff算法中有key\nfunction vnode(vm, tag, key, data, children, text) {\n    return {\n        vm,\n        tag,\n        key,\n        data,\n        children,\n        text\n        // .... 事件 插槽 指令\n    }\n}","// 1-6 导入定义好的创建元素节点和文本节点的方法\nimport Watcher from \"./observe/watcher\";\nimport { createElementVNode, createTextVNode } from \"./vdom\";\n\n// 1-9 根据虚拟节点创建新的真节点\nfunction createElm(vnode){\n    let {tag,data,children,text} = vnode;\n    // 先根据标签创建\n    if(typeof tag === 'string'){ // 标签\n        vnode.el =  document.createElement(tag); // 创建标签并赋值到虚拟节点上：这里将真实节点和虚拟节点对应起来，后续如果修改属性了，可以直接找到虚拟节点对应的真实节点\n        patchProps(vnode.el,data); // 更新这个标签上的属性\n        children.forEach(child => { // 标签的孩子\n            vnode.el.appendChild( createElm(child))\n        });\n    }else{ // 文本\n        vnode.el = document.createTextNode(text) // 创建文本并赋值到虚拟节点上\n    }\n    return vnode.el // 返回真实节点\n}\n// 1-10 更新属性\nfunction patchProps(el,props){\n    for(let key in props){\n        if(key === 'style'){ // style{color:'red'}\n            for(let styleName in props.style){\n                el.style[styleName] = props.style[styleName];\n            }\n        }else{\n            el.setAttribute(key,props[key]);\n        }\n    }\n}\n\n// 1-8 既有渲染又有更新：更新传老的虚拟节点，同时传入新的节点\nfunction patch(oldVNode,vnode) {\n    // 需要把原来的给删掉，创建一个新的\n    // 写的是初渲染流程 \n    const isRealElement = oldVNode.nodeType;\n    if(isRealElement){ // 如果有真实节点\n        const elm = oldVNode; // 获取真实元素\n        const parentElm = elm.parentNode; // 拿到父元素\n        // 1-11\n        let newElm =  createElm(vnode); // 根据虚拟节点创建新的真节点\n        parentElm.insertBefore(newElm,elm.nextSibling); // 找个原来节点的下一个节点，并把新的放入老节点的下面。\n        parentElm.removeChild(elm); // 删除老节点\n\n        return newElm\n    }else{\n        // diff算法\n    }\n}\n\n// 导出lifecycle\nexport function lifecycle(Vue) {\n    // 在Vue原型上扩展两个方法，下面的vm实例就可以调用\n    \n    //  1-2 1-7 将vnode转化成真实dom\n    Vue.prototype._update = function(vnode) {\n        console.log('update', vnode)\n        const vm = this;\n        const el = vm.$el;\n\n        // 1-7 patch既有初始化的功能  又有更新 \n        vm.$el = patch(el,vnode); // 用vnode创建真实的dom，替换掉原来的el\n    }\n\n    // 这几个方法都和虚拟节点及后面的diff算法有关，把这些方法都移到一个包里，vdom文件中\n    // 1-3  _c('div',{},...children) _c创建元素节点\n    Vue.prototype._c = function() {\n        return  createElementVNode(this,...arguments) // 实例和参数\n     }\n     // 1-4  _v(text)  _v创建文本节点\n     Vue.prototype._v = function() {\n         return createTextVNode(this,...arguments)\n     }\n     // 1-5  _s是变量转成字符串\n     Vue.prototype._s = function(value) {\n         if(typeof value !== 'object') return value\n         return JSON.stringify(value)\n     }\n    \n     // 1-1 渲染虚拟dom\n    //  执行render的时候，会执行里面的v c s方法，并去vm上取值\n     Vue.prototype._render = function() {\n        // 当渲染的时候会去实例中取值，我们就可以将属性和视图绑定在一起\n        return this.$options.render.call(this); // 这里的render是通过ast语法转义后生成的render方法如下注释部分。让with中的this指向vm。此时执行会报错因为_v,_c,_s方法都未定义，需要定义。\n    }\n}       \n        // render\n        // ƒ anonymous(\n        //     ) {\n        //     with(this){return _c('div',{id:\"app\"},_c('div',{style:{\"color\":\" red\",\"background\":\" pink\"}},_v(_s(name)+\"hello\"+_s(age))),_c('span',null,_v(_s(age))))}\n        //     }\n\n// 导出mountComponent方法\nexport function mountComponent(vm,el) { // 这里的el 是通过querySelector处理过的\n    vm.$el = el; // 把el挂载到vm实例上\n    // 1.调用render方法产生虚拟节点 虚拟DOM\n    vm._update(vm._render()); // vm.$options.render() 执行编译好的render方法，执行完后返回虚拟节点。vm._update方法是把虚拟节点变成真实节点\n\n    // 2.根据虚拟DOM产生真实DOM \n\n    // 3.插入到el元素中\n\n    // 4. 属性和我们的视图关联起来 做到数据变化可以自动更新视图 （观察者模式）observe/watcher.js（10 节课 实现vue的依赖收集）\n    const updateComponent = ()=> {\n        vm._update(vm._render())\n    }\n    // 这个watcher是个渲染watcher，只要new就会去调用这个updateComponent，并进行取值渲染\n    let wat = new Watcher(vm, updateComponent, true) // true用于标识是一个渲染watcher // new Watcher 会去执行class Watcher，里面进行页面渲染取值\n    console.log('wat', Watcher)\n}\n\n\n// vue核心流程 \n// 1） 创造了响应式数据  \n// 2） 模板转换成ast语法树  \n// 3) 将ast语法树转换了render函数 \n// 4) 后续每次数据更新可以只执行render函数 (无需再次执行ast转化的过程) // 通过传入不同的数据，render函数就可以返回不同的虚拟节点。\n// _render()函数根据数据创建最新的虚拟DOM节点（使用响应式数据）\n// _update()根据生成的虚拟节点创造真实的DOM,重新渲染\n\n","import { initState } from \"./state\"\n// import { compileToFunction } from \"./compiler/index\" // 安装插件后就不需要写index了，会默认找\nimport { compileToFunction } from \"./compiler\"\nimport { mountComponent } from \"./lifecycle\" // 导入生命周期\n\nexport function initMixin(Vue) { // 就是给Vue增加init方法\n    Vue.prototype._init = function(options) { // 用于初始化操作\n        // vue vm.$options 就是获取用户的配置\n        // 我们使用 vue的时候，所有以$开头的都是vue自己的属性。$nextTick $data $attr....\n        // 1. 把这个options放在实例上，在其他的方法里也可以拿到了。\n        const vm = this // 将实例this赋值给vm\n        vm.$options = options // 将用户的选项挂载到实例上\n\n        // 2. 初始化状态：data 事件 计算属性等\n        initState(vm)\n\n        // 7-1\n        // 如果options有el，就去挂载我们的应用\n        if(options.el) {\n            vm.$mount(options.el) // 实现数据的挂载\n        }\n    }\n    // 7-2\n    Vue.prototype.$mount = function(el) {\n        const vm = this \n        el = document.querySelector(el) // 获取元素，获取#app对应的节点\n        // 要判断一下用户的options里有没有写template模版？有没有写render函数？没有的话就用<div id=\"app\">\n        let ops = vm.$options\n        console.log(ops)\n        // （1）如果没有render需要去拿到模版转成render，如果有render直接赋值给ops\n        if (!ops.render) { // 先进行查找有没有render函数\n            let template // 没有render看一下是否写了template，没写template采用外部的template\n            if (!ops.template && el ) { // 没有写模版没有写render函数，就把el作为模版\n                template = el.outerHTML\n            } else {\n                if(el) {\n                    template = ops.template // 写了template,就用写了的template\n                }\n            }\n            console.log(template) // <div id=\"app\"><div>{{name}}</div><span>{{age}}</span></div>\n            // 需要将模版编译成render函数\n            if (template) {\n                const render = compileToFunction(template) // 把模版放进来，把模板变成了render函数\n                ops.render = render // jsx最终会被编译成h('xxx'), jsx是靠babel做的编译，有个插件plugin。？？？\n            }\n        }\n        // （2）如果有render函数，直接赋值render到vm.$options上\n        ops.render // 最终可以获取render方法\n\n\n        console.log('render', ops.render)\n        // ƒ anonymous(\n        //     ) {\n        //     with(this){return _c('div',{id:\"app\"},_c('div',{style:{\"color\":\" red\",\"background\":\" pink\"}},_v(_s(name)+\"hello\"+_s(age))),_c('span',null,_v(_s(age))))}\n        //     }\n\n        // 7-3 初步渲染 调用render方法\n        // 把当前的vm实例上的render调用一下，产生虚拟dom，再把虚拟dom渲染到el中去\n        mountComponent(vm, el); // 组件的挂载，挂载实例，实例里有render方法，挂载到元素el上\n\n        // script 标签引用的vue.global.js 这个编译过程是在浏览器运行的\n        // runtime运行时是不包含模版编译的，整个编译时打包的时候通过loader来转义.vue文件的。用runtime的时候不能使用模版（指的是template: '<div>hello</div>'属性）\n    }\n\n} \n\n","// class类是将所有的方法都耦合在一起不好维护\n// vue通过构造函数的方式，在其构造函数prototype上去添加方法，可以在多个文件去操作\n\nimport { initMixin } from \"./init\"\nimport { lifecycle } from \"./lifecycle\"\n\nfunction Vue(options) { // options就是用户的选项\n    this._init(options) // 默认就调用了init\n}\n\n// 把原型方法扩展成一个个函数\ninitMixin(Vue) // 扩展了init方法\n\n// 接入lifecycle.js\nlifecycle(Vue) // 扩展lifecycle方法\n\nexport default Vue"],"names":["oldArrayProto","Array","prototype","newArrayProto","Object","create","methods","forEach","method","args","result","call","console","log","ob","__ob__","inserted","slice","observeArray","id","Dep","constructor","subs","depend","target","addDep","addSub","watcher","push","notify","update","observe","data","Observer","defineProperty","value","enumerable","isArray","__proto__","walk","keys","key","defineReactive","item","dep","get","set","newValue","initState","vm","opts","$options","initData","_data","proxy","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","ELEMENT_TYPE","TEXT_TYPE","stack","currentParent","root","createASTElement","tag","attrs","type","children","parent","start","node","chars","text","length","replace","end","pop","advance","n","substring","parseStartTag","match","tagName","attr","name","textEnd","indexOf","startTagMatch","endTagMatch","defaultTagRE","genProps","str","i","obj","split","JSON","stringify","gen","codegen","test","tokens","lastIndex","exec","index","trim","join","genChildren","map","child","ast","code","compileToFunction","template","render","Function","Watcher","fn","options","renderWatcher","getter","deps","depsId","Set","has","add","createElementVNode","vnode","createTextVNode","undefined","createElm","el","document","createElement","patchProps","appendChild","createTextNode","props","styleName","style","setAttribute","patch","oldVNode","isRealElement","nodeType","elm","parentElm","parentNode","newElm","insertBefore","nextSibling","removeChild","lifecycle","Vue","_update","$el","_c","arguments","_v","_s","_render","mountComponent","updateComponent","initMixin","_init","$mount","querySelector","ops","outerHTML"],"mappings":"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"}