{"version":3,"file":"vue.js","sources":["../src/observe/array.js","../src/observe/index.js","../src/state.js","../src/init.js","../src/index.js"],"sourcesContent":["// 重写数组中的部分方法，最后把重写的对象返回出去\n\n// 1. 首先拿到原来的数组的方法，通过原型\nlet oldArrayProto = Array.prototype\n\n// 2. 不能直接修改原来的，需要扩展出来一份。生成一份新的数组方法\n// newArrayProto.__proto__ = oldArrayProto\nexport let newArrayProto = Object.create(oldArrayProto) // Object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。\n\n\n// 找到所有的变异方法，就是能修改原数组的方法\nlet methods = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'reverse',\n    'sort',\n    'splice'\n] // concat slice都不会改变原数组\n\n// 3. 重写这个方法\nmethods.forEach(method => {\n    // arr.push(1, 2, 3)\n    newArrayProto[method] = function(...args) { // 这里重写了数组的方法\n        // push.call(arr)\n        // todo...\n        const result = oldArrayProto[method].call(this, ...args) // 内部调用原来的方法，函数的劫持，叫做切片编程。这里的this谁调用方法push就指向谁，arr.push调用就指向arr\n        \n        console.log('method', method)\n        // 5. 拿到实例上的observeArray方法: 这里的this指的是调用方法的，data调用的，指向data,从data上获取属性__ob__，这个属性指向Observer的实例，拿到实例对象，就可以用它身上的observeArray方法\n        let ob = this.__ob__\n        // 4. 需要对新增的 数据再次进行劫持\n        let inserted\n        switch (method) {\n            case 'push':\n            case 'unshift': // arr.unshift(1, 2, 3)\n                inserted = args\n                break;\n            case 'splice': // arr.splice(0, 1, {a: 1}, {b: 2})\n                inserted = args.slice(2) // 截取从索引2开始往后的数据\n            default:\n                break;\n        }\n\n        console.log(inserted) // 新增的内容\n        if (inserted) {\n            // 6. 对新增的内容再次进行观测：如何观测？还是通过前面的observeArray去观测，但是这里是拿不到observeArray的，\n            // 只能拿到this，this指的是调用方法的对象，谁调用这些方法，this就是谁。在index.js可以看到data.__proto__ = newArrayProto，是data调用的这些方法，那么this指的就是data\n            ob.observeArray(inserted)\n\n        }\n\n\n\n        return result\n    }\n})\n","import { newArrayProto } from './array'\n\nexport function observe(data) {\n    // 对data这个对象进行劫持\n    // 5-1 判断是否是对象 // 只对对象进行劫持\n    if (typeof data !== 'object' || data == null) {\n        return\n    }\n    // 6-5 如果data上有个属性叫__ob__，它是类Observer的实例，说明这个对象被监测过了，直接把实例返回，不需要再观测了\n    if (data.__ob__ instanceof Observer) {\n        return data.__ob__\n    }\n\n    // 5-2 如果一个对象被劫持过了，那就不需要再被劫持了（要判断一个对象是否被劫持过，可以增添一个实例，用实例来判断是否被劫持过）\n    // 在内部又创建了一个类，这个类专门去观测数据的。如果这个数据被观测过，那么它的实例就是这个类\n    // 对data这个数据进行观测\n    return new Observer(data)\n\n}\n\n// 5-3\nclass Observer {\n    constructor(data) {\n        // 6-6 如果data是个对象的话，也会加一个__ob__属性，然后进入else中，去遍历每一项，遍历到__ob__发现是个对象；会再次进入到Observer中，再添加个_ob__这样就形成了死循环。？？？？【这里理解不透彻】\n        // 不能让data作为对象循环的时候遍历到这个__ob__属性，把它变成不可枚举类型，就可以了\n        Object.defineProperty(data, '__ob__', {\n            value: this,\n            enumerable: false // 将__ob__变成不可枚举（循环的时候无法获取到）\n        })\n        // // 6-4 // 在data上加一个自定义属性__ob__ 把this放上去，把，this指的是Observer的实例对象\n        // data.__ob__ = this  // 给数据加了一个标识，如果数据上有__ob__则说明这个属性被观测过了\n        // 6-1 对象可以遍历，数组有很多个，遍历会造成性能差。如果是数组，\n        if (Array.isArray(data)) {\n            // 6-3 这里可以重写数组中的方法 7个变异方法，是可以修改数组本身的。\n            data.__proto__ = newArrayProto // 需要保留数组原有的特性，并且可以重写部分方法\n            this.observeArray(data) // 如果数组中放的是对象，可以监控到对象的变化。\n        } else {\n            // 5-3 对这个数据的每个属性都劫持\n            // Object.defineProperty只能劫持已经存在的属性，后增的、或删除的是不知道的。（vue2里会为此单独写一些api $set $delete）\n            // 遍历这个对象\n            this.walk(data)\n        }\n    }\n\n    // 5-3 遍历对象进行观测\n    walk(data) { // 循环对象，重新定义属性，对属性依次劫持\n        // 重新定义属性 （性能差，相当于把属性重写了）\n        // defineReactive方法 把data这个数据定义成响应式的，属性是当前的key，值是当前的data[key]。这个方法没写在类里，写在外面可以导出，其他地方也可以使用。\n        Object.keys(data).forEach(key => defineReactive(data, key, data[key]))\n    }\n    // 6-2 遍历数组进行观测\n    observeArray(data) {\n        data.forEach(item => observe(item)) // 如果数组中存在引用类型，则劫持该项中的每一个属性\n    }\n}\n\n// 5-4\nexport function defineReactive(target, key, value) { // 属性劫持。闭包，里面的函数使用外面的value，这个变量不能被销毁\n    // 5-8 深度属性劫持。针对某个属性值还是个对象\n    observe(value) // 对所有的对象都进行属性劫持。\n    // 5-4\n    Object.defineProperty(target, key, {\n        get() { // 取值的时候会执行get\n            console.log('用户取值了')\n            return value\n        },\n        set(newValue) { // 修改的时候会执行set\n            console.log('用户设置值了')\n            if (newValue === value) return\n            observe(newValue) // 5-9 如果修改值的时候直接赋值个对象，对这个对象里的每个属性进行劫持\n            value = newValue\n        }\n    })\n\n}\n","import { observe } from \"./observe/index\"\n\nexport function initState(vm) {\n    const opts = vm.$options // 获取所有的选项\n    // 3. 如果选项中有data属性，则做数据初始化\n    if (opts.data) {\n        initData(vm)\n    }\n}\n// 4. 数据初始化\nfunction initData(vm) {\n    let data = vm.$options.data // data可能是函数和对象\n    data = typeof data === 'function' ? data.call(vm) : data // data是用户返回的对象\n    console.log(data)\n\n    // 5-5\n    // 把对象放在了实例上，并对这个对象进行了观测。此时去打印vm，会发现有个_data属性下面有name和age及其对应的get和set；但是取值需要通过vm._data.name取，无法直接通过vm.name取值\n    vm._data = data // 我将返回的对象放到了_data上\n\n    // 5. 对数据进行劫持\n    // vue2采用了一个api defineProperty\n    // 提供一个方法observe 去观测data数据: 响应式模块\n    observe(data)\n\n    // 5-6 想通过vm.xxx直接取值，需要将vm_data 用vm来代理就可以了。自己定义个方法\n    for(let key in data) {\n        proxy(vm, '_data', key) // 代理实例vm上的某个属性key叫_data。其实就是代理_data这个属性\n    }\n\n}\n\n// 5-7\nfunction proxy(vm, target, key) {\n    // 给vm对象，添加一个属性key，并给每个属性增加存取描述符属性\n    Object.defineProperty(vm, key, { // vm.name\n        get() {\n            return vm[target][key]   // vm._data.name\n        },\n        set(newValue) {\n            vm[target][key] = newValue\n        }\n    })\n}\n\n// 到这里就有两次数据劫持，一次是把用户的数据进行了属性劫持，一次是代理，当取值的时候代理到了某个值","import { initState } from \"./state\"\n\nexport function initMixin(Vue) { // 就是给Vue增加init方法\n    Vue.prototype._init = function(options) { // 用于初始化操作\n        // vue vm.$options 就是获取用户的配置\n        // 我们使用 vue的时候，所有以$开头的都是vue自己的属性。$nextTick $data $attr....\n        // 1. 把这个options放在实例上，在其他的方法里也可以拿到了。\n        const vm = this // 将实例this赋值给vm\n        vm.$options = options // 将用户的选项挂载到实例上\n\n        // 2. 初始化状态：data 事件 计算属性等\n        initState(vm)\n\n    }\n}\n\n","// class类是将所有的方法都耦合在一起不好维护\n// vue通过构造函数的方式，在其构造函数prototype上去添加方法，可以在多个文件去操作\n\nimport { initMixin } from \"./init\"\n\nfunction Vue(options) { // options就是用户的选项\n    this._init(options) // 默认就调用了init\n}\n\n// 把原型方法扩展成一个个函数\ninitMixin(Vue) // 扩展了init方法\n\nexport default Vue"],"names":["oldArrayProto","Array","prototype","newArrayProto","Object","create","methods","forEach","method","args","result","call","console","log","ob","__ob__","inserted","slice","observeArray","observe","data","Observer","constructor","defineProperty","value","enumerable","isArray","__proto__","walk","keys","key","defineReactive","item","target","get","set","newValue","initState","vm","opts","$options","initData","_data","proxy","initMixin","Vue","_init","options"],"mappings":"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"}