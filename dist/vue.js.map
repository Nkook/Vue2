{"version":3,"file":"vue.js","sources":["../src/observe/array.js","../src/observe/index.js","../src/state.js","../src/compiler/index.js","../src/init.js","../src/index.js"],"sourcesContent":["// 重写数组中的部分方法，最后把重写的对象返回出去\n\n// 1. 首先拿到原来的数组的方法，通过原型\nlet oldArrayProto = Array.prototype\n\n// 2. 不能直接修改原来的，需要扩展出来一份。生成一份新的数组方法\n// newArrayProto.__proto__ = oldArrayProto\nexport let newArrayProto = Object.create(oldArrayProto) // Object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。\n\n\n// 找到所有的变异方法，就是能修改原数组的方法\nlet methods = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'reverse',\n    'sort',\n    'splice'\n] // concat slice都不会改变原数组\n\n// 3. 重写这个方法\nmethods.forEach(method => {\n    // arr.push(1, 2, 3)\n    newArrayProto[method] = function(...args) { // 这里重写了数组的方法\n        // push.call(arr)\n        // todo...\n        const result = oldArrayProto[method].call(this, ...args) // 内部调用原来的方法，函数的劫持，叫做切片编程。这里的this谁调用方法push就指向谁，arr.push调用就指向arr\n        \n        console.log('method', method)\n        // 5. 拿到实例上的observeArray方法: 这里的this指的是调用方法的，data调用的，指向data,从data上获取属性__ob__，这个属性指向Observer的实例，拿到实例对象，就可以用它身上的observeArray方法\n        let ob = this.__ob__\n        // 4. 需要对新增的 数据再次进行劫持\n        let inserted\n        switch (method) {\n            case 'push':\n            case 'unshift': // arr.unshift(1, 2, 3)\n                inserted = args\n                break;\n            case 'splice': // arr.splice(0, 1, {a: 1}, {b: 2})\n                inserted = args.slice(2) // 截取从索引2开始往后的数据\n            default:\n                break;\n        }\n\n        console.log(inserted) // 新增的内容\n        if (inserted) {\n            // 6. 对新增的内容再次进行观测：如何观测？还是通过前面的observeArray去观测，但是这里是拿不到observeArray的，\n            // 只能拿到this，this指的是调用方法的对象，谁调用这些方法，this就是谁。在index.js可以看到data.__proto__ = newArrayProto，是data调用的这些方法，那么this指的就是data\n            ob.observeArray(inserted)\n\n        }\n\n\n\n        return result\n    }\n})\n","import { newArrayProto } from './array'\n\nexport function observe(data) {\n    // 对data这个对象进行劫持\n    // 5-1 判断是否是对象 // 只对对象进行劫持\n    if (typeof data !== 'object' || data == null) {\n        return\n    }\n    // 6-5 如果data上有个属性叫__ob__，它是类Observer的实例，说明这个对象被监测过了，直接把实例返回，不需要再观测了\n    if (data.__ob__ instanceof Observer) {\n        return data.__ob__\n    }\n\n    // 5-2 如果一个对象被劫持过了，那就不需要再被劫持了（要判断一个对象是否被劫持过，可以增添一个实例，用实例来判断是否被劫持过）\n    // 在内部又创建了一个类，这个类专门去观测数据的。如果这个数据被观测过，那么它的实例就是这个类\n    // 对data这个数据进行观测\n    return new Observer(data)\n\n}\n\n// 5-3\nclass Observer {\n    constructor(data) {\n        // 6-6 如果data是个对象的话，也会加一个__ob__属性，然后进入else中，去遍历每一项，遍历到__ob__发现是个对象；会再次进入到Observer中，再添加个_ob__这样就形成了死循环。？？？？【这里理解不透彻】\n        // 不能让data作为对象循环的时候遍历到这个__ob__属性，把它变成不可枚举类型，就可以了\n        Object.defineProperty(data, '__ob__', {\n            value: this,\n            enumerable: false // 将__ob__变成不可枚举（循环的时候无法获取到）\n        })\n        // // 6-4 // 在data上加一个自定义属性__ob__ 把this放上去，把，this指的是Observer的实例对象\n        // data.__ob__ = this  // 给数据加了一个标识，如果数据上有__ob__则说明这个属性被观测过了\n        // 6-1 对象可以遍历，数组有很多个，遍历会造成性能差。如果是数组，\n        if (Array.isArray(data)) {\n            // 6-3 这里可以重写数组中的方法 7个变异方法，是可以修改数组本身的。\n            data.__proto__ = newArrayProto // 需要保留数组原有的特性，并且可以重写部分方法\n            this.observeArray(data) // 如果数组中放的是对象，可以监控到对象的变化。\n        } else {\n            // 5-3 对这个数据的每个属性都劫持\n            // Object.defineProperty只能劫持已经存在的属性，后增的、或删除的是不知道的。（vue2里会为此单独写一些api $set $delete）\n            // 遍历这个对象\n            this.walk(data)\n        }\n    }\n\n    // 5-3 遍历对象进行观测\n    walk(data) { // 循环对象，重新定义属性，对属性依次劫持\n        // 重新定义属性 （性能差，相当于把属性重写了）\n        // defineReactive方法 把data这个数据定义成响应式的，属性是当前的key，值是当前的data[key]。这个方法没写在类里，写在外面可以导出，其他地方也可以使用。\n        Object.keys(data).forEach(key => defineReactive(data, key, data[key]))\n    }\n    // 6-2 遍历数组进行观测\n    observeArray(data) {\n        data.forEach(item => observe(item)) // 如果数组中存在引用类型，则劫持该项中的每一个属性\n    }\n}\n\n// 5-4\nexport function defineReactive(target, key, value) { // 属性劫持。闭包，里面的函数使用外面的value，这个变量不能被销毁\n    // 5-8 深度属性劫持。针对某个属性值还是个对象\n    observe(value) // 对所有的对象都进行属性劫持。\n    // 5-4\n    Object.defineProperty(target, key, {\n        get() { // 取值的时候会执行get\n            console.log('用户取值了')\n            return value\n        },\n        set(newValue) { // 修改的时候会执行set\n            console.log('用户设置值了')\n            if (newValue === value) return\n            observe(newValue) // 5-9 如果修改值的时候直接赋值个对象，对这个对象里的每个属性进行劫持\n            value = newValue\n        }\n    })\n\n}\n","import { observe } from \"./observe/index\"\n\nexport function initState(vm) {\n    const opts = vm.$options // 获取所有的选项\n    // 3. 如果选项中有data属性，则做数据初始化\n    if (opts.data) {\n        initData(vm)\n    }\n}\n// 4. 数据初始化\nfunction initData(vm) {\n    let data = vm.$options.data // data可能是函数和对象\n    data = typeof data === 'function' ? data.call(vm) : data // data是用户返回的对象\n    console.log(data)\n\n    // 5-5\n    // 把对象放在了实例上，并对这个对象进行了观测。此时去打印vm，会发现有个_data属性下面有name和age及其对应的get和set；但是取值需要通过vm._data.name取，无法直接通过vm.name取值\n    vm._data = data // 我将返回的对象放到了_data上\n\n    // 5. 对数据进行劫持\n    // vue2采用了一个api defineProperty\n    // 提供一个方法observe 去观测data数据: 响应式模块\n    observe(data)\n\n    // 5-6 想通过vm.xxx直接取值，需要将vm_data 用vm来代理就可以了。自己定义个方法\n    for(let key in data) {\n        proxy(vm, '_data', key) // 代理实例vm上的某个属性key叫_data。其实就是代理_data这个属性\n    }\n\n}\n\n// 5-7\nfunction proxy(vm, target, key) {\n    // 给vm对象，添加一个属性key，并给每个属性增加存取描述符属性\n    Object.defineProperty(vm, key, { // vm.name\n        get() {\n            return vm[target][key]   // vm._data.name\n        },\n        set(newValue) {\n            vm[target][key] = newValue\n        }\n    })\n}\n\n// 到这里就有两次数据劫持，一次是把用户的数据进行了属性劫持，一次是代理，当取值的时候代理到了某个值","// <div id=\"app\">\n//    <div>{{name}}</div>\n//    <span>{{age}}</span>\n// </div>\n// 3. vue2采用正则 匹配标签 属性 表达式\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 匹配标签名<div></div>\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 匹配到的分组是一个 标签名  <xxx 匹配到的是开始 标签的名字\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`);  // 匹配的是</xxxx>  最终匹配到的分组就是结束标签的名字\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;  // 匹配属性 a = \"123\"\n// 第一个分组就是属性的key value就是分组3/分组4/分组5\nconst startTagClose = /^\\s*(\\/?)>/;  // 匹配结束标签 </div> <br/>\n// const defaultTagRE = /\\{((?:.|\\r?\\n)+?)\\}\\}/g  // 匹配到的内容就是表达式的变量{{aa}}\n\n// vue3 采用的不是使用正则\n\n// 对模版进行编译处理\n// 1-1\nfunction parseHTML(html) { // html最开始肯定是一个 <div   <div>hello</div>\n    //  1-13 最终需要转化成一颗抽象语法树，需要构建父子关系。\n    // 栈型结构，栈中的最后一个元素是当前匹配到开始标签的父亲。匹配到<div>放入栈；匹配到<div>放进栈，匹配到</div>结束标签时，再把<div>扔出去；匹配到<span>放入，匹配到</span>移除....\n    const ELEMENT_TYPE = 1; // 元素类型为1\n    const TEXT_TYPE = 3;    // 文本类型为3\n    const stack = []; // 用于存放元素的栈\n    let currentParent; // 指向的是栈中的最后一个\n    let root; // 是否是根节点\n\n    // 最终需要转化成一颗抽象语法树：一个节点包含标签名称、类型、子元素、属性、父元素\n    function createASTElement(tag, attrs) {\n        return {\n            tag,\n            type: ELEMENT_TYPE,\n            children: [],\n            attrs,\n            parent: null\n        }\n    }\n    //  1-11 现在只是把标签文本删掉了，并没有做任何处理替换。对这些进行处理，需要这几个方法暴漏出去，在解析到开始标签、文本、结束标签的时候进行替换。\n    // 1-11-1遇到开始节点创建节点，没有根节点，就是树根；如果有父节点，那就设置为当前节点的父节点，并把当前节点作为父节点的孩子；将节点放入栈中，更更新为当前父节点\n    // 利用栈型结构 来构造一颗树\n    function start(tag, attrs) {\n        // console.log('开始标签', tag, attrs)\n        let node = createASTElement(tag, attrs) // 创造一个ast节点\n        if (!root) { // 看一下是否空树，如果没有root根节点，那么这个节点就作为树的根节点\n            root = node\n        }\n        if(currentParent){ // 如果当前父节点有值，将当前节点的父亲节点设置为currentParent\n            node.parent = currentParent; // 只赋予了parent属性\n            currentParent.children.push(node); // 还需要让父亲记住自己\n        }\n        stack.push(node) // 将节点放入栈中\n        currentParent = node; // currentParent作为栈中的最后一个节点\n    }\n    // 1-11-2 对于文本直接放入当前父节点的子节点中\n    function chars(text) { // 文本直接放到当前指向的节点中\n        console.log('文本', text, text.length)\n        text = text.replace(/\\s/g,''); // 如果空格超过2就删除2个以上的\n        text && currentParent.children.push({\n            type:TEXT_TYPE,\n            text,\n            parent:currentParent\n        });\n    }\n    // 1-11-3 遇到结束标签，弹出该节点，并将最后一个节点更新为当前父节点\n    function end(tag) {\n        // console.log('结束标签', tag)\n        let node =  stack.pop();  // 遇到结束节点，弹出栈中最后一个。可以通过tag和node对比 校验标签是否合法\n       currentParent = stack[stack.length - 1]; // 更新当前父节点\n    }\n    // 1-4 \n    function advance(n) {\n        html = html.substring(n) // 截取的长度就是匹配到的开始标签的长度 '<div'\n    }\n    // 1-3 解析开始标签 并返回匹配的结果\n    function parseStartTag() {\n        const start = html.match(startTagOpen) // 用html通过正则匹配看是否是开始标签\n        // console.log('start', start) // ['<div', 'div', index: 0, input: '<div id=\"app\">\\n        <div>{{name}}</div>\\n        <span>{{age}}</span>\\n    </div>', groups: undefined]\n        if (start) { // 如果匹配到了就是开始标签：把结果组成一个对象，把标签名、对应的属性放进去\n            const match = {\n                tagName: start[1], // 标签名\n                attrs: [] // 属性\n            }\n            // console.log(match) // {tagName: 'div', attrs: Array(0)}\n            // 1-4 需要对html不停的解析，已经解析过的要删除掉。比如，解析了开始标签，把<div>删除掉，再解析 id='app'属性。所以要有个删除的过程，写个方法，叫前进，前进长度就是匹配到的内容的总长度\n            advance(start[0].length);\n            // console.log(start[0], html) // 打印可以看到匹配一段就少一段 <div   id=\"app\"><div>{{name}}</div><span>{{age}}</span></div>\n            \n            // 1-5 匹配属性：只要不是开始标签的结束!html.match(startTagClose，就一直匹配下去；拿到每次匹配的属性html.match(attribute)放到数组attr中。删除掉匹配的属性\n            let attr, end\n            while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n                advance(attr[0].length); // id=\"app\"就删掉了\n                // 1-6 需要把属性解析出来放到attrs属性中去\n                match.attrs.push({ name: attr[1], value: attr[3] || attr[4] || attr[5] || true })\n            }\n            // 也应该把结束标签>删掉, 如果end有值就删除\n            if (end) {\n                advance(end[0].length);\n            }\n            return match\n            // 1-6\n            // console.log(match) // {tagName: 'div', attrs: [{name: 'id', value: 'app'}]}\n        }\n\n        // 否则不是开始标签\n        return false\n    }\n    // debugger 可以看整个过程\n    // 1-2 整个过程：遇到开始标签解析开始标签，遇到文本解析文本，遇到结束标签解析结束标签\n    while(html) { // 每解析一个标签就把它从这个字符串中删除掉，整个模版字符串都没有了就解析完了 // while : 在…. 期间， 所以 while循环 就是在满足条件期间，重复执行某些代码。 continue：结束本次循环，继续下次循环。break：跳出所在的循环\n        // 如果textEnd 为0 说明是一个开始标签或者结束标签 如： <div>hello</div>\n        // 如果textEnd > 0说明就是文本的结束位置\n        let textEnd = html.indexOf('<') // 如果indexof中的索引是0 则说明是个标签\n        // 1-2 解析标签\n        if (textEnd == 0) {\n            // 1-3\n            const startTagMatch = parseStartTag() // 解析开始标签 // 开始标签的匹配结果: 先匹配开始标签，再匹配属性，再匹配结束标签；并把已经匹配到的从html模版字符中删除掉；返回匹配到的结果对象{tagName: 标签名, attrs: 属性}\n            // 1-7 如果是【开始标签】有值，跳过本轮操作，继续再往下走\n            if (startTagMatch) { // 解析到的开始标签\n                // 1-12\n                start(startTagMatch.tagName, startTagMatch.attrs)\n                // console.log(html) // 这个时候看到还是开始标签 <div>{{name}}</div><span>{{age}}</span></div>\n                continue // 为啥跳出本次循环，因为开始标签移除后，再重新循环html去找结束标签就好了。下面的代码就不再走了，如果不写，就走到下面解析文本了\n            }\n            \n            // 1-9 如果不是开始标签，就是【结束标签】。匹配到后直接删除\n            let endTagMatch = html.match(endTag); // 通过正则匹配结束标签，返回当前结束标签的名字\n            if (endTagMatch) { // 如果有值就删除掉\n                advance(endTagMatch[0].length);\n                // 1-12\n                end(endTagMatch[1])\n                continue;\n            }\n        }\n        // 1-8 解析【文本】内容\n        if (textEnd > 0) {\n            let text = html.substring(0, textEnd); // 文本内容\n            if (text) {\n                // 1-12\n                chars(text)\n                advance(text.length); // 解析到的文本 \n            }\n        }\n    }\n    console.log('root', root)\n    return root\n    // console.log(html, '====')\n}\n\n\nexport function compileToFunction(template) {\n    // 1. 将template转化成ast语法树（模版针对的就是上面的内容：对于标签解析的是标签名、文本、表达式、属性、字符串等）\n    let ast = parseHTML(template)\n    // 2. 生成render方法（render方法执行后的返回结果就是 虚拟DOM）\n\n    // console.log(template)\n}","import { initState } from \"./state\"\n// import { compileToFunction } from \"./compiler/index\" // 安装插件后就不需要写index了，会默认找\nimport { compileToFunction } from \"./compiler\"\n\nexport function initMixin(Vue) { // 就是给Vue增加init方法\n    Vue.prototype._init = function(options) { // 用于初始化操作\n        // vue vm.$options 就是获取用户的配置\n        // 我们使用 vue的时候，所有以$开头的都是vue自己的属性。$nextTick $data $attr....\n        // 1. 把这个options放在实例上，在其他的方法里也可以拿到了。\n        const vm = this // 将实例this赋值给vm\n        vm.$options = options // 将用户的选项挂载到实例上\n\n        // 2. 初始化状态：data 事件 计算属性等\n        initState(vm)\n\n        // 7-1\n        // 如果options有el，就去挂载我们的应用\n        if(options.el) {\n            vm.$mount(options.el) // 实现数据的挂载\n        }\n    }\n    // 7-2\n    Vue.prototype.$mount = function(el) {\n        const vm = this \n        el = document.querySelector(el) // 获取元素，获取#app对应的节点\n        // 要判断一下用户的options里有没有写template模版？有没有写render函数？没有的话就用<div id=\"app\">\n        let ops = vm.$options\n        console.log(ops)\n        // （1）如果没有render需要去拿到模版转成render，如果有render直接赋值给ops\n        if (!ops.render) { // 先进行查找有没有render函数\n            let template // 没有render看一下是否写了template，没写template采用外部的template\n            if (!ops.template && el ) { // 没有写模版没有写render函数，就把el作为模版\n                template = el.outerHTML\n            } else {\n                if(el) {\n                    template = ops.template // 写了template,就用写了的template\n                }\n            }\n            console.log(template) // <div id=\"app\"><div>{{name}}</div><span>{{age}}</span></div>\n            // 需要将模版编译成render函数\n            if (template) {\n                const render = compileToFunction(template) // 把模版放进来\n                ops.render = render // jsx最终会被编译成h('xxx'), jsx是靠babel做的编译，有个插件plugin。？？？\n            }\n        }\n        // （2）赋值render到vm.$options上\n        ops.render // 最终可以获取render方法\n\n        // script 标签引用的vue.global.js 这个编译过程是在浏览器运行的\n        // runtime运行时是不包含模版编译的，整个编译时打包的时候通过loader来转义.vue文件的。用runtime的时候不能使用模版（指的是template: '<div>hello</div>'属性）\n    }\n\n} \n\n","// class类是将所有的方法都耦合在一起不好维护\n// vue通过构造函数的方式，在其构造函数prototype上去添加方法，可以在多个文件去操作\n\nimport { initMixin } from \"./init\"\n\nfunction Vue(options) { // options就是用户的选项\n    this._init(options) // 默认就调用了init\n}\n\n// 把原型方法扩展成一个个函数\ninitMixin(Vue) // 扩展了init方法\n\nexport default Vue"],"names":["oldArrayProto","Array","prototype","newArrayProto","Object","create","methods","forEach","method","args","result","call","console","log","ob","__ob__","inserted","slice","observeArray","observe","data","Observer","constructor","defineProperty","value","enumerable","isArray","__proto__","walk","keys","key","defineReactive","item","target","get","set","newValue","initState","vm","opts","$options","initData","_data","proxy","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","ELEMENT_TYPE","TEXT_TYPE","stack","currentParent","root","createASTElement","tag","attrs","type","children","parent","start","node","push","chars","text","length","replace","end","pop","advance","n","substring","parseStartTag","match","tagName","attr","name","textEnd","indexOf","startTagMatch","endTagMatch","compileToFunction","template","initMixin","Vue","_init","options","el","$mount","document","querySelector","ops","render","outerHTML"],"mappings":"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"}