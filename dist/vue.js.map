{"version":3,"file":"vue.js","sources":["../src/observe/dep.js","../src/observe/array.js","../src/observe/index.js","../src/observe/watcher.js","../src/state.js","../src/compiler/parse.js","../src/compiler/index.js","../src/vdom/index.js","../src/lifecycle.js","../src/init.js","../src/index.js"],"sourcesContent":["// 首次渲染的时候会收集， 更新的时候会再次收集。\n// 只有在模板里取值的时候，才会做依赖收集。\n\nlet id = 0;\n// 8-1. 每个属性都有dep，创建一个类\nclass Dep{\n    constructor(){\n        this.id = id++; // 属性的dep要收集watcher；每次执行id就++\n        console.log('id===', id)\n        this.subs = [];// 这里存放着当前属性对应的watcher有哪些; 一个属性可能有多个watcher（一个属性可以在a组件用，b组件用...）；\n        // 8-3 \n        // 此时再去boserve/index.js中给每个属性增加dep，let dep = new Dep()\n        // 有了dep也有了watcher，如何让他俩关联起来？可以把当前的watcher暴漏在全局上；Dep.target = null;\n        // 在watcher.js中把当前的watcher赋值给全局变量Dep.target\n    }\n    // 8-5\n    depend(){\n        // 这里我们不希望放重复的watcher，而且刚才只是一个单向的关系 dep收集-> watcher；也希望 watcher记录 ->dep\n        // watcher 记录dep\n        // this.subs.push(Dep.target); // 把当前的watcher放入这个栈中。这样存在重复。因为每次\n\n        Dep.target.addDep(this); // 让当前watcher（Dep.target）记住dep。 在watcher.js中实现这个方法。\n\n        // 8-7\n        // dep 和 watcher是一个多对多的关系 （一个属性可以在多个组件中使用 dep -> 多个watcher）\n        // 一个组件中由多个属性组成 （一个watcher 对应多个dep）\n    }\n    // 8-6\n    addSub(watcher){\n        this.subs.push(watcher) // 将watcher放入subs\n        console.log('this.subs', this.subs)\n    }  \n    // 8-8\n    notify(){\n        this.subs.forEach(watcher=>watcher.update()); // 告诉watcher要更新了，让这里subs所有记住的依赖都调用更新方法\n    }\n}\n// 8-4\nDep.target = null; // 可以把当前的watcher暴漏在全局上\n\n// 第13节课 实现计算属性\n// 栈形结构\nlet stack = [];\n// 渲染之前让watcher入栈\nexport function pushTarget(watcher){\n    stack.push(watcher);\n    Dep.target = watcher;\n}\n// 渲染之后让这个watcher出栈 删除\nexport function popTarget(){\n    stack.pop();\n    Dep.target = stack[stack.length - 1];\n}\n\n// 8-2. 导出\nexport default Dep;\n","// 重写数组中的部分方法，最后把重写的对象返回出去\n\n// 1. 首先拿到原来的数组的方法，通过原型\nlet oldArrayProto = Array.prototype\n\n// 2. 不能直接修改原来的，需要扩展出来一份。生成一份新的数组方法\n// newArrayProto.__proto__ = oldArrayProto\nexport let newArrayProto = Object.create(oldArrayProto) // Object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。\n\n\n// 找到所有的变异方法，就是能修改原数组的方法\nlet methods = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'reverse',\n    'sort',\n    'splice'\n] // concat slice都不会改变原数组\n\n// 3. 重写这个方法\nmethods.forEach(method => {\n    // arr.push(1, 2, 3)\n    newArrayProto[method] = function(...args) { // 这里重写了数组的方法\n        // push.call(arr)\n        // todo...\n        const result = oldArrayProto[method].call(this, ...args) // 内部调用原来的方法，函数的劫持，叫做切片编程。这里的this谁调用方法push就指向谁，arr.push调用就指向arr\n        \n        console.log('method', method)\n        // 5. 拿到实例上的observeArray方法: 这里的this指的是调用方法的，data调用的，指向data,从data上获取属性__ob__，这个属性指向Observer的实例，拿到实例对象，就可以用它身上的observeArray方法\n        let ob = this.__ob__\n        // 4. 需要对新增的 数据再次进行劫持\n        let inserted\n        switch (method) {\n            case 'push':\n            case 'unshift': // arr.unshift(1, 2, 3)\n                inserted = args\n                break;\n            case 'splice': // arr.splice(0, 1, {a: 1}, {b: 2})\n                inserted = args.slice(2) // 截取从索引2开始往后的数据\n            default:\n                break;\n        }\n\n        console.log(inserted) // 新增的内容\n        if (inserted) {\n            // 6. 对新增的内容再次进行观测：如何观测？还是通过前面的observeArray去观测，但是这里是拿不到observeArray的，\n            // 只能拿到this，this指的是调用方法的对象，谁调用这些方法，this就是谁。在index.js可以看到data.__proto__ = newArrayProto，是data调用的这些方法，那么this指的就是data\n            ob.observeArray(inserted)\n\n        }\n\n\n        // 11-4 \n        // console.log('更新了')\n        ob.dep.notify()\n        \n        return result\n    }\n})\n","import { newArrayProto } from './array'\nimport Dep from './dep'\n\nexport function observe(data) {\n    // 对data这个对象进行劫持\n    // 5-1 判断是否是对象 // 只对对象进行劫持\n    if (typeof data !== 'object' || data == null) {\n        return\n    }\n    // 6-5 如果data上有个属性叫__ob__，它是类Observer的实例，说明这个对象被监测过了，直接把实例返回，不需要再观测了\n    if (data.__ob__ instanceof Observer) {\n        return data.__ob__\n    }\n\n    // 5-2 如果一个对象被劫持过了，那就不需要再被劫持了（要判断一个对象是否被劫持过，可以增添一个实例，用实例来判断是否被劫持过）\n    // 在内部又创建了一个类，这个类专门去观测数据的。如果这个数据被观测过，那么它的实例就是这个类\n    // 对data这个数据进行观测\n    return new Observer(data)\n\n}\n\n// 5-3\nclass Observer {\n    constructor(data) {\n\n        // 11. 第11节课 数组更新实现原理\n        // 11-1 给每个对象都增加收集功能\n        this.dep = new Dep()\n\n        \n        // 6-6 如果data是个对象的话，也会加一个__ob__属性，然后进入else中，去遍历每一项，遍历到__ob__发现是个对象；会再次进入到Observer中，再添加个_ob__这样就形成了死循环。？？？？【这里理解不透彻】\n        // 不能让data作为对象循环的时候遍历到这个__ob__属性，把它变成不可枚举类型，就可以了\n        Object.defineProperty(data, '__ob__', {\n            value: this,\n            enumerable: false // 将__ob__变成不可枚举（循环的时候无法获取到）\n        })\n        // // 6-4 // 在data上加一个自定义属性__ob__ 把this放上去，把，this指的是Observer的实例对象\n        // data.__ob__ = this  // 给数据加了一个标识，如果数据上有__ob__则说明这个属性被观测过了\n        // 6-1 对象可以遍历，数组有很多个，遍历会造成性能差。如果是数组，\n        if (Array.isArray(data)) {\n            // 6-3 这里可以重写数组中的方法 7个变异方法，是可以修改数组本身的。\n            data.__proto__ = newArrayProto // 需要保留数组原有的特性，并且可以重写部分方法\n            this.observeArray(data) // 如果数组中放的是对象，可以监控到对象的变化。\n        } else {\n            // 5-3 对这个数据的每个属性都劫持\n            // Object.defineProperty只能劫持已经存在的属性，后增的、或删除的是不知道的。（vue2里会为此单独写一些api $set $delete）\n            // 遍历这个对象\n            this.walk(data)\n        }\n    }\n\n    // 5-3 遍历对象进行观测\n    walk(data) { // 循环对象，重新定义属性，对属性依次劫持\n        // 重新定义属性 （性能差，相当于把属性重写了）\n        // defineReactive方法 把data这个数据定义成响应式的，属性是当前的key，值是当前的data[key]。这个方法没写在类里，写在外面可以导出，其他地方也可以使用。\n        Object.keys(data).forEach(key => defineReactive(data, key, data[key]))\n    }\n    // 6-2 遍历数组进行观测\n    observeArray(data) {\n        data.forEach(item => observe(item)) // 如果数组中存在引用类型，则劫持该项中的每一个属性\n    }\n}\n// 11-6 深层次嵌套会递归，递归多了性能差，不存在属性监控不到，存在的属性要重写方法  vue3-> proxy\nfunction dependArray(value){\n    for(let i = 0; i < value.length;i++){\n        let current = value[i]\n        current.__ob__ && current.__ob__.dep.depend();\n        if(Array.isArray(current)){\n            dependArray(current);\n        }\n    }\n}\n\n// 5-4\nexport function defineReactive(target, key, value) { // 属性劫持。闭包，里面的函数使用外面的value，这个变量不能被销毁\n    // 5-8 深度属性劫持。针对某个属性值还是个对象\n    // observe(value) // 对所有的对象都进行属性劫持。\n\n    // 11-2 这个value上就有dep childOb.dep用来收集依赖\n    let childOb = observe(value) \n\n    // 在第10节课：lifecycle.js给每个属性增加dep: 有了dep也有了watcher，如何让他俩关联起来\n    // 10-1\n    let dep = new Dep() // data里的属性只会被劫持一次，在劫持该属性的时候给每个属性增加dep, 增加的dep都有唯一id，页面渲染取值会触发get，每次触发get的时候去进行watcher收集了。为了避免多次get收集重复的watcher所以就拿该属性的id进行去重！\n    // 5-4\n    Object.defineProperty(target, key, {\n        get() { // 取值的时候会执行get\n            console.log('用户取值了')\n            // 10-2 属性的dep收集watcher\n            if(Dep.target){\n                dep.depend(); // 让这个属性的收集器记住当前的watcher；去dep.js中增加个方法depend\n\n                // 11-3 取值arr数组的时候，childOb有值，让数组和对象本身也实现依赖收集。在array.js当调用arr相关方法时，进行dep.notify()更新\n                if (childOb) {\n                    childOb.dep.depend()\n                    // 11-5 如果数组中还嵌套数组，继续对嵌套的数组进行依赖收集。递归处理\n                    if(Array.isArray(value)){\n                        dependArray(value);\n                    }\n                }\n            }\n            return value\n        },\n        set(newValue) { // 修改的时候会执行set\n            console.log('用户设置值了')\n            if (newValue === value) return\n            observe(newValue) // 5-9 如果修改值的时候直接赋值个对象，对这个对象里的每个属性进行劫持\n            value = newValue\n            // 10-3 属性更新 让dep去更新视图\n            dep.notify() // 通知更新\n        }\n    })\n\n}\n","\n// 10. 整个过程：\n// 1）当我们渲染的时候会创建watcher，我们会把当前的渲染watcher放到全局dep.target上。\n// 2）然后取值调用_render()；取值会走到index.js的get上；    this.getter = fn；fn是vm._update(vm._render())；\n        // 在observe/index.js的 get方法上进行判断，当前属性的dep是否有target，有的话就让这个属性的收集器记住当前的watcher\n\nimport Dep, { popTarget, pushTarget } from './dep'\nconsole.log('Dep', Dep)\n\n\n// 1. 需要区分是哪个watcher，每个组件都会有一个watcher，这样某个组件更新只需要更新这个组件的watcher就好。组件的特点：复用，方便维护，局部更新\n// 每次创建一个watcher都给一个唯一的id\nlet id = 0\n\n// 2. 创建一个watcher类（是个渲染的类）\nclass Watcher { // 不同组件有不同的watcher,每个组件都需要去创建一个watcher, 目前只有一个 渲染根实例的\n    // vm是当前watcher是哪个实例，fn要做哪些事（渲染函数)，options是参数 \n    constructor(vm, fn, options) {\n        this.id = id++;\n        // 7. 渲染watcher  // 8. 接着需要给每个属性增加dep创建observe/dep.js\n        this.renderWatcher = options; // 这里做个标识是一个渲染watcher\n        // 4. 把渲染的方法fn封装到了当前watcher中。这个函数是具备取值操作的，因为要渲染到页面上\n        this.getter = fn; // getter意味着调用这个函数可以发生取值操作。fn是vm._update(vm._render())\n        // 11. 收集dep: dep收集watcher的同时，让watcher也记录dep。// 后续我们实现计算属性，和一些清理工作需要用到\n        //      去到dep.js中做处理 Dep.target.addDep(this)，把当前属性的dep传给watcher\n        this.deps = [];\n        // 13. 通过set对重复属性进行去重。如果一个属性在多个地方使用，不需要重复去收集watcher\n        this.depsId = new Set();\n        // // 5. 页面初次渲染，如果首次传入进来fn但是不调用的话，那么页面第一次是无法渲染的。\n        // this.get();\n\n        // 第13节课 计算属性传入的\n        this.lazy = options.lazy;\n        this.dirty = this.lazy; // 缓存值\n        this.vm = vm;\n        this.lazy ? undefined : this.get()\n    }\n    // 12. 一个组件有多个属性，重复的属性也不用记录。去重\n    // 这里实现了watcher收集dep，dep收集watcher，并进行了去重。\n    addDep(dep) { \n        let id = dep.id;\n        // 14. data里的属性只会被劫持一次，在劫持该属性的时候给每个属性增加dep, 增加的dep都有唯一id，页面渲染取值会触发get，每次触发get的时候去进行watcher收集了。为了避免多次get收集重复的watcher所以就拿该属性的id进行去重！\n        if (!this.depsId.has(id)) {\n            this.deps.push(dep); // watcher记住这个dep \n            this.depsId.add(id); // 并将这个塞入depsId中，用于下次判断\n            dep.addSub(this); // dep记住watcher。\n        }\n    }\n    // 第13节课\n    evaluate(){\n        this.value =  this.get(); // 获取到用户函数的返回值 并且还要标识为脏 \n        this.dirty = false;\n    }\n    // 6. 首次取值需要调用 this.getter()也就是vm._update(vm._render()) 这个渲染方法\n    get() {\n        // // 9. 在dep.js中增加个变量叫target。在执行watcher之前把这个watcher放到全局变量Dep上\n        // Dep.target = this // 把当前的watcher赋值给全局变量（类中的this指的都是当前的实例）；\n        // this.getter() // 调用_render()会取值，会去vm上取值；取值的时候\n        // Dep.target = null // 视图渲染完成后清空\n\n        // 第13节课 实现计算属性\n        // 这里维护成队列，不再只放入一个watcher\n        pushTarget(this)// 静态属性就是只有一份\n        let value = this.getter.call(this.vm); // 会去vm上取值  vm._update(vm._render) 取name 和age\n        popTarget() // 渲染完毕后就清空\n        return value; // 拿到函数执行后的返回值\n\n    }\n    // 15. 更新属性时需要调用更新\n    // 这个watcher就可以理解为观察者，会观察某个属性。\n    // 【每个属性有一个dep（属性就是被观察者），watcher就是观察者（属性变化了会通知观察者来更新），-> 观察者模式】\n    update() {\n        // // 16. 11节课实现异步更新原理\n        // // 实现该方法，通过防抖实现走完所有同步任务，再去更新页面\n        // queueWatcher(this); // 把当前的watcher 暂存起来\n        // // this.get(); // 属性更新后， 重新渲染。（缺点：每次更新一个属性触发set后都要重新update渲染，应该等到同步的设置值都完成后再去更新页面）\n\n        // 第13节课\n        if(this.lazy){\n            // 如果是计算属性  依赖的值变化了 就标识计算属性是脏值了\n            this.dirty = true;\n        }else{\n            queueWatcher(this); // 把当前的watcher 暂存起来\n            // this.get(); // 重新渲染\n        }\n    }\n    run() {\n        this.get()\n    }  \n\n    // 第13节课\n    depend(){ // watcher的depend 就是让watcher中dep去depend\n        let i =  this.deps.length;\n        while(i--){\n            // dep.depend()\n            this.deps[i].depend(); // 让计算属性watcher 也收集渲染watcher\n        }\n    }\n}\n\nlet queue = []\nlet has = {}\nlet pending = false // 防抖，无论触发多少次只走一次\n// 18. 刷新操作，页面渲染\nfunction flushSchedulerQueue () {\n    let flushQueue = queue.slice(0)\n    queue = []\n    has = {}\n    pending = false\n    flushQueue.forEach(q => q.run()) // 在刷新的过程中可能还有新的watcher，重新放到queue中\n}\n// 17. 对watcher进行去重，并只调用一次。\nfunction queueWatcher (watcher) {\n    // 一个页面上的多个属性对应的是同一个watcher。去重\n    const id = watcher.id\n    if (!has[id]) {\n        queue.push(watcher)\n        has[id] = true\n        console.log('queue', queue)\n        // 不管我们的update执行多少次，但是最终只执行一轮刷新操作。\n        if (!pending) {\n            setTimeout(flushSchedulerQueue, 0)\n            pending = true\n        }\n    }\n}\n\n// 18.内部更新使用nexTick，外部用户在html页面手动更新时，也调用nexTick。于是把该方法挂载到vm原型上，在html页面就可以调用\n// nexTick将异步任务维护到队列中\n\nlet callbacks = []\nlet waiting = false\n// 19. 异步批处理\nfunction flushCallbacks() {\n    let cbs = callbacks.slice(0)\n    waiting = false\n    callbacks = []\n    cbs.forEach(cb => cb()) // 按照顺序依次执行\n}\n\n// 20. nextTick 没有直接使用某个api 而是采用优雅降级的方式 \n// 内部先采用的是promise （ie不兼容）  MutationObserver(h5的api)  可以考虑ie专享的 setImmediate  setTimeout\n// let timerFunc;\n// if (Promise) {\n//     timerFunc = () => {\n//         Promise.resolve().then(flushCallbacks)\n//     }\n// }else if(MutationObserver){\n//     let observer = new MutationObserver(flushCallbacks); // 这里传入的回调是异步执行的\n//     let textNode = document.createTextNode(1);\n//     observer.observe(textNode,{\n//         characterData:true\n//     });\n//     timerFunc = () => {\n//         textNode.textContent = 2;\n//     }\n// }else if(setImmediate){\n//     timerFunc = () => {\n//        setImmediate(flushCallbacks);\n//     }\n// }else{\n//     timerFunc = () => {\n//         setTimeout(flushCallbacks);\n//      }\n// }\nexport function nexTick(cb) { // 先内部还是先页面用户手动触发的？谁在前先执行谁。nexTick里将方法放入队列的方法是同步的，执行刷新是异步的。\n    callbacks.push(cb) // 维护nexTick中的callback方法\n    if (!waiting) {\n        // setTimeout(() => {\n            // flushCallbacks() // 最后一起刷新\n            // 21. 优雅降级 兼容多浏览器。比setTimeout更快，需要开启一个新线程，promise只是插入一个异步\n            // timerFunc()\n            // 22. vue3 直接使用promise\n            Promise.resolve().then(flushCallbacks)\n        // }, 0)\n        waiting = true\n    }\n}\n\n// 6. 需要让每个属性和watcher关联起来\n/**\n * 需要给每个属性增加一个dep， 目的就是收集watcher\n * 一个组件对应一个watcher，一个组件中有多个属性，多个属性对应一个watcher\n * 一个属性有一个watcher，一个属性存在于多个组件中，一个属性对应多个watcher\n * \n * （变量本身是和watcher没有关联的，想关联需要分配dep，让dep把watcher收集起来）\n * 多对多的关系\n */\n\n// 3. 导出类，在3.index.html中进行 new Watcher并传入实例和回调函数\nexport default Watcher","import Dep from \"./observe/dep\";\nimport { observe } from \"./observe/index\"\nimport Watcher from \"./observe/watcher\";\n\nexport function initState(vm) {\n    const opts = vm.$options // 获取所有的选项\n    // 3. 如果选项中有data属性，则做数据初始化\n    if (opts.data) {\n        initData(vm)\n    }\n\n    // 第13节课计算属性\n    if (opts.computed) {\n        initComputed(vm);\n    }\n}\n// 4. 数据初始化\nfunction initData(vm) {\n    let data = vm.$options.data // data可能是函数和对象\n    data = typeof data === 'function' ? data.call(vm) : data // data是用户返回的对象\n    console.log(data)\n\n    // 5-5\n    // 把对象放在了实例上，并对这个对象进行了观测。此时去打印vm，会发现有个_data属性下面有name和age及其对应的get和set；但是取值需要通过vm._data.name取，无法直接通过vm.name取值\n    vm._data = data // 我将返回的对象放到了_data上\n\n    // 5. 对数据进行劫持\n    // vue2采用了一个api defineProperty\n    // 提供一个方法observe 去观测data数据: 响应式模块\n    observe(data)\n\n    // 5-6 想通过vm.xxx直接取值，需要将vm_data 用vm来代理就可以了。自己定义个方法\n    for(let key in data) {\n        proxy(vm, '_data', key) // 代理实例vm上的某个属性key叫_data。其实就是代理_data这个属性\n    }\n\n}\n\n// 5-7\nfunction proxy(vm, target, key) {\n    // 给vm对象，添加一个属性key，并给每个属性增加存取描述符属性\n    Object.defineProperty(vm, key, { // vm.name\n        get() {\n            return vm[target][key]   // vm._data.name\n        },\n        set(newValue) {\n            vm[target][key] = newValue\n        }\n    })\n}\n// 到这里就有两次数据劫持，一次是把用户的数据进行了属性劫持，一次是代理，当取值的时候代理到了某个值\n\n// 第13节课 计算属性\nfunction initComputed(vm) {\n    // 取到用户写的所有的计算属性：存在两种写法\n    const computed = vm.$options.computed;\n    const watchers = vm._computedWatchers = {}; // 将计算属性watcher保存到vm上\n    for (let key in computed) { // 根据是对象还是函数分别做处理。\n        let userDef = computed[key];\n\n        // 我们需要监控 计算属性中get的变化\n        let fn = typeof userDef === 'function' ? userDef : userDef.get\n\n        // 如果直接new Watcher 默认就会执行fn, 将属性和watcher对应起来 \n        // 不希望fn立刻执行，希望取值的时候再执行，增加{ lazy: true }\n        watchers[key] = new Watcher(vm, fn, { lazy: true }) // 一个计算属性对应一个watcher\n\n        defineComputed(vm, key, userDef); // 定义的时候就给当前vm实例上增加一个fullname，值为一个函数\n    }\n}\nfunction defineComputed(target, key, userDef) {\n    // const getter = typeof userDef === 'function' ? userDef : userDef.get;\n    const setter = userDef.set || (() => { })\n\n    // 可以通过实例拿到对应的属性\n    Object.defineProperty(target, key, {\n        get: createComputedGetter(key), // 页面{{fullname}} 取值时就会走这个get。现在是每次取值都走一遍，需要根据属性值没有变化时，不再走get\n        set: setter\n    })\n}\n// 计算属性根本不会收集依赖 ，只会让自己的依赖属性去收集依赖\nfunction createComputedGetter(key) {\n    // 我们需要检测是否要执行这个getter\n    return function () { \n        const watcher = this._computedWatchers[key]; // 获取到对应属性的watcher // this是当前的vm\n        if (watcher.dirty) {\n            // 如果是脏的就去执行 用户传入的 函数\n            watcher.evaluate(); // 求值后 dirty变为了false ,下次就不求值了\n        }\n        if (Dep.target) { // 计算属性出栈后 还要渲染watcher， 我应该让计算属性watcher里面的属性 也去收集上一层watcher\n            watcher.depend();\n        }\n        return watcher.value; // 最后返回的是watcher上的值\n    }\n}","// <div id=\"app\">\n//    <div>{{name}}</div>\n//    <span>{{age}}</span>\n// </div>\n// 3. vue2采用正则 匹配标签 属性 表达式\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 匹配标签名<div></div>\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 匹配到的分组是一个 标签名  <xxx 匹配到的是开始 标签的名字\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`);  // 匹配的是</xxxx>  最终匹配到的分组就是结束标签的名字\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;  // 匹配属性 a = \"123\"\n// 第一个分组就是属性的key value就是分组3/分组4/分组5\nconst startTagClose = /^\\s*(\\/?)>/;  // 匹配结束标签 </div> <br/>\n// const defaultTagRE = /\\{((?:.|\\r?\\n)+?)\\}\\}/g  // 匹配到的内容就是表达式的变量{{aa}}\n\n// vue3 采用的不是使用正则\n\n// 对模版进行编译处理\n// 1-1\nexport function parseHTML(html) { // html最开始肯定是一个 <div   <div>hello</div>\n    //  1-13 最终需要转化成一颗抽象语法树，需要构建父子关系。\n    // 栈型结构，栈中的最后一个元素是当前匹配到开始标签的父亲。匹配到<div>放入栈；匹配到<div>放进栈，匹配到</div>结束标签时，再把<div>扔出去；匹配到<span>放入，匹配到</span>移除....\n    const ELEMENT_TYPE = 1; // 元素类型为1\n    const TEXT_TYPE = 3;    // 文本类型为3\n    const stack = []; // 用于存放元素的栈\n    let currentParent; // 指向的是栈中的最后一个\n    let root; // 是否是根节点\n\n    // 最终需要转化成一颗抽象语法树：一个节点包含标签名称、类型、子元素、属性、父元素\n    function createASTElement(tag, attrs) {\n        return {\n            tag,\n            type: ELEMENT_TYPE,\n            children: [],\n            attrs,\n            parent: null\n        }\n    }\n    //  1-11 现在只是把标签文本删掉了，并没有做任何处理替换。对这些进行处理，需要这几个方法暴漏出去，在解析到开始标签、文本、结束标签的时候进行替换。\n    // 1-11-1遇到开始节点创建节点，没有根节点，就是树根；如果有父节点，那就设置为当前节点的父节点，并把当前节点作为父节点的孩子；将节点放入栈中，更更新为当前父节点\n    // 利用栈型结构 来构造一颗树\n    function start(tag, attrs) {\n        // console.log('开始标签', tag, attrs)\n        let node = createASTElement(tag, attrs) // 创造一个ast节点\n        if (!root) { // 看一下是否空树，如果没有root根节点，那么这个节点就作为树的根节点\n            root = node\n        }\n        if(currentParent){ // 如果当前父节点有值，将当前节点的父亲节点设置为currentParent\n            node.parent = currentParent; // 只赋予了parent属性\n            currentParent.children.push(node); // 还需要让父亲记住自己\n        }\n        stack.push(node) // 将节点放入栈中\n        currentParent = node; // currentParent作为栈中的最后一个节点\n    }\n    // 1-11-2 对于文本直接放入当前父节点的子节点中\n    function chars(text) { // 文本直接放到当前指向的节点中\n        console.log('文本', text, text.length)\n        text = text.replace(/\\s/g,''); // 如果空格超过2就删除2个以上的\n        text && currentParent.children.push({\n            type:TEXT_TYPE,\n            text,\n            parent:currentParent\n        });\n    }\n    // 1-11-3 遇到结束标签，弹出该节点，并将最后一个节点更新为当前父节点\n    function end(tag) {\n        // console.log('结束标签', tag)\n        let node =  stack.pop();  // 遇到结束节点，弹出栈中最后一个。可以通过tag和node对比 校验标签是否合法\n       currentParent = stack[stack.length - 1]; // 更新当前父节点\n    }\n    // 1-4 \n    function advance(n) {\n        html = html.substring(n) // 截取的长度就是匹配到的开始标签的长度 '<div'\n    }\n    // 1-3 解析开始标签 并返回匹配的结果\n    function parseStartTag() {\n        const start = html.match(startTagOpen) // 用html通过正则匹配看是否是开始标签\n        // console.log('start', start) // ['<div', 'div', index: 0, input: '<div id=\"app\">\\n        <div>{{name}}</div>\\n        <span>{{age}}</span>\\n    </div>', groups: undefined]\n        if (start) { // 如果匹配到了就是开始标签：把结果组成一个对象，把标签名、对应的属性放进去\n            const match = {\n                tagName: start[1], // 标签名\n                attrs: [] // 属性\n            }\n            // console.log(match) // {tagName: 'div', attrs: Array(0)}\n            // 1-4 需要对html不停的解析，已经解析过的要删除掉。比如，解析了开始标签，把<div>删除掉，再解析 id='app'属性。所以要有个删除的过程，写个方法，叫前进，前进长度就是匹配到的内容的总长度\n            advance(start[0].length);\n            // console.log(start[0], html) // 打印可以看到匹配一段就少一段 <div   id=\"app\"><div>{{name}}</div><span>{{age}}</span></div>\n            \n            // 1-5 匹配属性：只要不是开始标签的结束!html.match(startTagClose，就一直匹配下去；拿到每次匹配的属性html.match(attribute)放到数组attr中。删除掉匹配的属性\n            let attr, end\n            while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n                advance(attr[0].length); // id=\"app\"就删掉了\n                // 1-6 需要把属性解析出来放到attrs属性中去\n                match.attrs.push({ name: attr[1], value: attr[3] || attr[4] || attr[5] || true })\n            }\n            // 也应该把结束标签>删掉, 如果end有值就删除\n            if (end) {\n                advance(end[0].length);\n            }\n            return match\n            // 1-6\n            // console.log(match) // {tagName: 'div', attrs: [{name: 'id', value: 'app'}]}\n        }\n\n        // 否则不是开始标签\n        return false\n    }\n    // debugger 可以看整个过程\n    // 1-2 整个过程：遇到开始标签解析开始标签，遇到文本解析文本，遇到结束标签解析结束标签\n    while(html) { // 每解析一个标签就把它从这个字符串中删除掉，整个模版字符串都没有了就解析完了 // while : 在…. 期间， 所以 while循环 就是在满足条件期间，重复执行某些代码。 continue：结束本次循环，继续下次循环。break：跳出所在的循环\n        // 如果textEnd 为0 说明是一个开始标签或者结束标签 如： <div>hello</div>\n        // 如果textEnd > 0说明就是文本的结束位置\n        let textEnd = html.indexOf('<') // 如果indexof中的索引是0 则说明是个标签\n        // 1-2 解析标签\n        if (textEnd == 0) {\n            // 1-3\n            const startTagMatch = parseStartTag() // 解析开始标签 // 开始标签的匹配结果: 先匹配开始标签，再匹配属性，再匹配结束标签；并把已经匹配到的从html模版字符中删除掉；返回匹配到的结果对象{tagName: 标签名, attrs: 属性}\n            // 1-7 如果是【开始标签】有值，跳过本轮操作，继续再往下走\n            if (startTagMatch) { // 解析到的开始标签\n                // 1-12\n                start(startTagMatch.tagName, startTagMatch.attrs)\n                // console.log(html) // 这个时候看到还是开始标签 <div>{{name}}</div><span>{{age}}</span></div>\n                continue // 为啥跳出本次循环，因为开始标签移除后，再重新循环html去找结束标签就好了。下面的代码就不再走了，如果不写，就走到下面解析文本了\n            }\n            \n            // 1-9 如果不是开始标签，就是【结束标签】。匹配到后直接删除\n            let endTagMatch = html.match(endTag); // 通过正则匹配结束标签，返回当前结束标签的名字\n            if (endTagMatch) { // 如果有值就删除掉\n                advance(endTagMatch[0].length);\n                // 1-12\n                end(endTagMatch[1])\n                continue;\n            }\n        }\n        // 1-8 解析【文本】内容\n        if (textEnd > 0) {\n            let text = html.substring(0, textEnd); // 文本内容\n            if (text) {\n                // 1-12\n                chars(text)\n                advance(text.length); // 解析到的文本 \n            }\n        }\n    }\n    console.log('root', root)\n    return root\n    // console.log(html, '====')\n}","// 将html转成ast语法树\nimport { parseHTML } from \"./parse\";\n\n// 2-6\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; // {{ asdsadsa }}  匹配到的内容就是我们表达式的变量\n\n// 2-2 遍历当前节点属性，把每一项通过字符串进行拼接；遇到style需要用大括号{style:{color:'red'}}\nfunction genProps(attrs) {\n    //attrs属性在ast树上是个数组[{name: 'style', value: 'color: red; background: pink;'}]\n    // 转成 {style:{\"color\":\" red\",\"background\":\" pink\"}}\n    let str = ''// {name: value}\n    for (let i = 0; i < attrs.length; i++) {\n        let attr = attrs[i];\n        if (attr.name === 'style') {\n            // color:red;background:red => {color:'red', background:'red'}\n            let obj = {};\n            attr.value.split(';').forEach(item => { // 先通过分号分割成数组，再循环组成对象\n                let [key, value] = item.split(':');\n                obj[key] = value;\n            });\n            attr.value = obj\n        }\n        str += `${attr.name}:${JSON.stringify(attr.value)},` // [{name: 'id', value: 'app'}] 转成 {id:\"app\"}\n    }\n    return `{${str.slice(0, -1)}}` // 去除最后一个字符逗号\n}\n// 2-5 如果是文本创建文本，如果是标签创建标签\n// _c创建元素， _v创建文本， _s是变量转成字符串\n// 过程：1）先判断是文本还是标签，如果是标签调用codegen方法，拼接tag标签，再拼接该标签的属性，再拼接该节点的孩子\n//      2）如果是文本，分为纯文本和含有{{变量}}的文本; \n//          2.1）通过正则匹配该文本中是否含有变量，如果没有，直接转成字符串拼接；\n//          2.2) 如果存在有变量，分三种情况处理。循环该文本正则匹配到值，并依次放入数组中tokens\n//                  如果匹配到的变量索引 > 最后一个索引值(默认0)，说明两个变量中间存在纯文本，需要通过slice截取出来放入tokens中\n//                  如果匹配到的变量索引为0，将匹配到的变量直接放入tokens中，并将最后索引值更新为 = 当前变量的索引值+当前变量的长度\n//                  如果最后索引值 < text整个文本的总长度，说明后面还有纯文本，通过slice截取后面的字符放入tokens中\nfunction gen(node) {\n    console.log('node', node)\n    if (node.type === 1) { // 标签，需要调用方法 去 拼接tag标签，再拼接该标签的属性，再拼接节点的孩子\n        return codegen(node);\n    } else { // 纯文本，需要分两种情况 {{name}}hello   呵呵\n        let text = node.text  \n        if (!defaultTagRE.test(text)) { // 是否是纯文本，如果是文本 什么都不用做，直接返回这个纯文本字符。defaultTagRE.test('hello') == false   defaultTagRE.test('{{name}}hello') == true\n            return `_v(${JSON.stringify(text)})`\n        } else {\n            //_v( _s(name)+'hello' + _s(age))\n            let tokens = [];\n            let match; // 匹配到的文本\n            defaultTagRE.lastIndex = 0; // 正则里面含有/g的话，exec每次用过之后需要重置位置，否则只能被捕获到一次\n            let lastIndex = 0;\n            // split\n            while (match = defaultTagRE.exec(text)) { // 通过正则匹配到有变量的文本赋值给match。 这里的text是{{name}}hello{{age}}\n                console.log('match', match) //  ['{{name}}', 'name', index: 0, input: '{{name}}hello{{age}}', groups: undefined]  ['{{age}}', 'age', index: 13, input: '{{name}}hello{{age}}', groups: undefined]\n                let index = match.index; // 匹配变量的位置: 比如第一个{{name}}位置是0，第二个{{age}}是13。 {{name}} hello {{age}} hello\n                if (index > lastIndex) { // 匹配的第二个变量的位置比上一次更新的位置大的话，说明两个变量之间存在文本，需要把文本放进去。\n                    tokens.push(JSON.stringify(text.slice(lastIndex, index))) // 截取 最后一次位置到当前第二个变量的位置就是中 纯文本\n                }\n                tokens.push(`_s(${match[1].trim()})`)\n                lastIndex = index + match[0].length // lastIndex等于当前匹配的位置加上当前匹配到变量的长度，就是整个文本最后一次的位置。 {{name}} hello {{age}}第一次index是0，长度是{{name}}8，最后一次位置更新为8\n            }\n            if (lastIndex < text.length) { // 最后匹配的位置小余整个文本的长度，需要把后面的纯文本放入\n                tokens.push(JSON.stringify(text.slice(lastIndex)))\n            }\n            console.log('tokens', tokens) //  ['_s(name)', '\"hello\"', '_s(age)']\n            return `_v(${tokens.join('+')})`\n        }\n    }\n}\n// 2-4 遍历子节点 \nfunction genChildren(children) {\n    return children.map(child => gen(child)).join(',')\n}\n// 2-1\nfunction codegen(ast) {\n    // 2-3 拼接子节点\n    let children = genChildren(ast.children);\n    // 2-1拼接tag标签，再拼接该标签的属性，再拼接节点的孩子\n    // _c('div',{id:\"app\"},_c('div',{style:{\"color\":\" red\",\"background\":\" pink\"}},_v(_s(name)+\"hello\"+_s(age))),_c('span',null,_v(_s(age))))\n    let code = (`_c('${ast.tag}',${ast.attrs.length > 0 ? genProps(ast.attrs) : 'null'\n        }${ast.children.length ? `,${children}` : ''\n        })`)\n\n    return code;\n}\n\n\nexport function compileToFunction(template) {\n    // 1. 将template转化成ast语法树（模版针对的就是上面的内容：对于标签解析的是标签名、文本、表达式、属性、字符串等）\n    let ast = parseHTML(template)\n    console.log(ast)\n    // 2. 将语法树 转成render方法（render方法执行后的返回结果就是 虚拟DOM）\n    // 2-1 \n    let code = codegen(ast) // 拿到的是字符串，想让字符串运行\n    // console.log('code', code) //  _c('div',{id:\"app\"},_c('div',{style:{\"color\":\" red\",\"background\":\" pink\"}},_v(_s(name)+\"hello\"+_s(age))),_c('span',null,_v(_s(age))))\n\n    // 2-7 模板引擎的实现原理 就是 with  + new Function\n    code = `with(this){return ${code}}` // 将编译后的结果包装成with。with为了取值方便，this是谁就从谁身上取值。对象属性直接变成了with作用域下的\n    let render = new Function(code) // 根据字符串生成render函数\n    \n    // console.log(render.toString()) 打印结果如下\n    // function anonymous(\n    //     ) {\n    //     with(this){return _c('div',{id:\"app\"},_c('div',{style:{\"color\":\" red\",\"background\":\" pink\"}},_v(_s(name)+\"hello\"+_s(age))),_c('span',null,_v(_s(age))))}\n    //     }\n    // 通过call改变this指向vm\n    // render.call(vm)\n\n    return render\n\n    // 生成一个函数，叫render函数，参数h，里面需要创建个div，div有自己的属性；还有自己的儿子及其属性；还有个表达式文本内容，表达式可能是对象，先JSON.stringify转成字符串\n    // 创建一个元素_c，\n    // 元素有个儿子叫div,属性叫id: app；有一个儿子叫div属性叫style:{color: 'red'}；儿子里面放的是个变量可能是字符串，先JSON.stringify转正字符串，再拼接hello\n    // 还有一个儿子叫span，没有属性，有个变量叫age\n    // 实现_c  _v  _s方法就可以了。最终把ast树组装成下面这样的语法就结束了\n    // 先不考虑render函数，可以通过new Function 生成函数，先考虑这个返回值。\n    // render() {\n    //     return _c('div',{id:\"app\"},_c('div',{style:{\"color\":\" red\",\"background\":\" pink\"}},_v(_s(name)+\"hello\"+_s(age))),_c('span',null,_v(_s(age))))\n    // }\n    \n}\n\n// let obj = {}\n// with(obj) {\n//     console.log(this.a) // 这里的this就是obj,使用with时，里面的取值都会从obj上取\n// }\n\n// ast树\n// {tag: 'div', type: 1, children: Array(2), attrs: Array(1), parent: null}\n//     attrs: Array(1)\n//         0: {name: 'id', value: 'app'}\n//         length: 1\n//         [[Prototype]]: Array(0)\n//     children: Array(2)\n//         0: {tag: 'div', type: 1, children: Array(1), attrs: Array(1), parent: {…}}\n//         1: {tag: 'span', type: 1, children: Array(1), attrs: Array(0), parent: {…}}\n//         length: 2\n//         [[Prototype]]: Array(0)\n//     parent: null\n//     tag: \"div\"\n//     type: 1\n//     [[Prototype]]: Object\n\n// children\n// children: Array(2)\n//     0:\n//         attrs: Array(1)\n//             0:\n//                 name: \"style\"\n//                 value: {color: ' red', background: ' pink', \"\": undefined}\n//                 [[Prototype]]: Object\n//                 length: 1\n//                 [[Prototype]]: Array(0)\n//         children: Array(1)\n//             0: {type: 3, text: '{{name}}hello{{age}}', parent: {…}}\n//             length: 1\n//             [[Prototype]]: Array(0)\n//         parent: {tag: 'div', type: 1, children: Array(2), attrs: Array(1), parent: null}\n//         tag: \"div\"\n//         type: 1\n//         [[Prototype]]: Object\n//     1: {tag: 'span', type: 1, children: Array(1), attrs: Array(0), parent: {…}}\n//     length: 2\n//     [[Prototype]]: Array(0)\n//     parent: null\n//     tag: \"div\"\n//     type: 1\n//     [[Prototype]]: Object","// 专门用于构建虚拟dom的方法\n\n// 1. h()  _c() 创建元素的虚拟节点\nexport function createElementVNode(vm, tag, data, ...children) {\n    if (data == null) {\n        data = {}\n    }\n    let key = data.key; // 属性的key值\n    if (key) {\n        delete data.key\n    }\n    return vnode(vm, tag, key, data, children); // 虚拟节点上有vm实例，标签，key，属性，孩子\n}\n// 3. _v();  创建文本的虚拟节点\nexport function createTextVNode(vm, text) {\n    return vnode(vm, undefined, undefined, undefined, undefined, text);\n}\n// 和ast一样吗？ ast做的是语法层面的转化 他描述的是语法本身 (可以描述js css html)\n// 2. 我们的虚拟dom 是描述的dom元素，可以增加一些自定义属性  (描述dom的)\n// diff算法中有key\nfunction vnode(vm, tag, key, data, children, text) {\n    return {\n        vm,\n        tag,\n        key,\n        data,\n        children,\n        text\n        // .... 事件 插槽 指令\n    }\n}","// 1-6 导入定义好的创建元素节点和文本节点的方法\nimport Watcher from \"./observe/watcher\";\nimport { createElementVNode, createTextVNode } from \"./vdom\";\n\n// 1-9 根据虚拟节点创建新的真节点\nfunction createElm(vnode){\n    let {tag,data,children,text} = vnode;\n    // 先根据标签创建\n    if(typeof tag === 'string'){ // 标签\n        vnode.el =  document.createElement(tag); // 创建标签并赋值到虚拟节点上：这里将真实节点和虚拟节点对应起来，后续如果修改属性了，可以直接找到虚拟节点对应的真实节点\n        patchProps(vnode.el,data); // 更新这个标签上的属性\n        children.forEach(child => { // 标签的孩子\n            vnode.el.appendChild( createElm(child))\n        });\n    }else{ // 文本\n        vnode.el = document.createTextNode(text) // 创建文本并赋值到虚拟节点上\n    }\n    return vnode.el // 返回真实节点\n}\n// 1-10 更新属性\nfunction patchProps(el,props){\n    for(let key in props){\n        if(key === 'style'){ // style{color:'red'}\n            for(let styleName in props.style){\n                el.style[styleName] = props.style[styleName];\n            }\n        }else{\n            el.setAttribute(key,props[key]);\n        }\n    }\n}\n\n// 1-8 既有渲染又有更新：更新传老的虚拟节点，同时传入新的节点\nfunction patch(oldVNode,vnode) {\n    // 需要把原来的给删掉，创建一个新的\n    // 写的是初渲染流程 \n    const isRealElement = oldVNode.nodeType;\n    if(isRealElement){ // 如果有真实节点\n        const elm = oldVNode; // 获取真实元素\n        const parentElm = elm.parentNode; // 拿到父元素\n        // 1-11\n        let newElm =  createElm(vnode); // 根据虚拟节点创建新的真节点\n        parentElm.insertBefore(newElm,elm.nextSibling); // 找个原来节点的下一个节点，并把新的放入老节点的下面。\n        parentElm.removeChild(elm); // 删除老节点\n\n        return newElm\n    }else{\n        // diff算法\n    }\n}\n\n// 导出lifecycle\nexport function lifecycle(Vue) {\n    // 在Vue原型上扩展两个方法，下面的vm实例就可以调用\n    \n    //  1-2 1-7 将vnode转化成真实dom\n    Vue.prototype._update = function(vnode) {\n        console.log('update', vnode)\n        const vm = this;\n        const el = vm.$el;\n\n        // 1-7 patch既有初始化的功能  又有更新 \n        vm.$el = patch(el,vnode); // 用vnode创建真实的dom，替换掉原来的el\n    }\n\n    // 这几个方法都和虚拟节点及后面的diff算法有关，把这些方法都移到一个包里，vdom文件中\n    // 1-3  _c('div',{},...children) _c创建元素节点\n    Vue.prototype._c = function() {\n        return  createElementVNode(this,...arguments) // 实例和参数\n     }\n     // 1-4  _v(text)  _v创建文本节点\n     Vue.prototype._v = function() {\n         return createTextVNode(this,...arguments)\n     }\n     // 1-5  _s是变量转成字符串\n     Vue.prototype._s = function(value) {\n         if(typeof value !== 'object') return value\n         return JSON.stringify(value)\n     }\n    \n     // 1-1 渲染虚拟dom\n    //  执行render的时候，会执行里面的v c s方法，并去vm上取值\n     Vue.prototype._render = function() {\n        // 当渲染的时候会去实例中取值，我们就可以将属性和视图绑定在一起\n        return this.$options.render.call(this); // 这里的render是通过ast语法转义后生成的render方法如下注释部分。让with中的this指向vm。此时执行会报错因为_v,_c,_s方法都未定义，需要定义。\n    }\n}       \n        // render\n        // ƒ anonymous(\n        //     ) {\n        //     with(this){return _c('div',{id:\"app\"},_c('div',{style:{\"color\":\" red\",\"background\":\" pink\"}},_v(_s(name)+\"hello\"+_s(age))),_c('span',null,_v(_s(age))))}\n        //     }\n\n// 导出mountComponent方法\nexport function mountComponent(vm,el) { // 这里的el 是通过querySelector处理过的\n    vm.$el = el; // 把el挂载到vm实例上\n    // 1.调用render方法产生虚拟节点 虚拟DOM\n    vm._update(vm._render()); // vm.$options.render() 执行编译好的render方法，执行完后返回虚拟节点。vm._update方法是把虚拟节点变成真实节点\n\n    // 2.根据虚拟DOM产生真实DOM \n\n    // 3.插入到el元素中\n\n    // 4. 属性和我们的视图关联起来 做到数据变化可以自动更新视图 （观察者模式）observe/watcher.js（10 节课 实现vue的依赖收集）\n    const updateComponent = ()=> {\n        vm._update(vm._render())\n    }\n    // 这个watcher是个渲染watcher，只要new就会去调用这个updateComponent，并进行取值渲染\n    let wat = new Watcher(vm, updateComponent, true) // true用于标识是一个渲染watcher // new Watcher 会去执行class Watcher，里面进行页面渲染取值\n    console.log('wat', Watcher)\n}\n\n\n// vue核心流程 \n// 1） 创造了响应式数据  \n// 2） 模板转换成ast语法树  \n// 3) 将ast语法树转换了render函数 \n// 4) 后续每次数据更新可以只执行render函数 (无需再次执行ast转化的过程) // 通过传入不同的数据，render函数就可以返回不同的虚拟节点。\n// _render()函数根据数据创建最新的虚拟DOM节点（使用响应式数据）\n// _update()根据生成的虚拟节点创造真实的DOM,重新渲染\n\n","import { initState } from \"./state\"\n// import { compileToFunction } from \"./compiler/index\" // 安装插件后就不需要写index了，会默认找\nimport { compileToFunction } from \"./compiler\"\nimport { mountComponent } from \"./lifecycle\" // 导入生命周期\n\nexport function initMixin(Vue) { // 就是给Vue增加init方法\n    Vue.prototype._init = function(options) { // 用于初始化操作\n        // vue vm.$options 就是获取用户的配置\n        // 我们使用 vue的时候，所有以$开头的都是vue自己的属性。$nextTick $data $attr....\n        // 1. 把这个options放在实例上，在其他的方法里也可以拿到了。\n        const vm = this // 将实例this赋值给vm\n        vm.$options = options // 将用户的选项挂载到实例上\n\n        // 2. 初始化状态：data 事件 计算属性等\n        initState(vm)\n\n        // 7-1\n        // 如果options有el，就去挂载我们的应用\n        if(options.el) {\n            vm.$mount(options.el) // 实现数据的挂载\n        }\n    }\n    // 7-2\n    Vue.prototype.$mount = function(el) {\n        const vm = this \n        el = document.querySelector(el) // 获取元素，获取#app对应的节点\n        // 要判断一下用户的options里有没有写template模版？有没有写render函数？没有的话就用<div id=\"app\">\n        let ops = vm.$options\n        console.log(ops)\n        // （1）如果没有render需要去拿到模版转成render，如果有render直接赋值给ops\n        if (!ops.render) { // 先进行查找有没有render函数\n            let template // 没有render看一下是否写了template，没写template采用外部的template\n            if (!ops.template && el ) { // 没有写模版没有写render函数，就把el作为模版\n                template = el.outerHTML\n            } else {\n                if(el) {\n                    template = ops.template // 写了template,就用写了的template\n                }\n            }\n            console.log(template) // <div id=\"app\"><div>{{name}}</div><span>{{age}}</span></div>\n            // 需要将模版编译成render函数\n            if (template) {\n                const render = compileToFunction(template) // 把模版放进来，把模板变成了render函数\n                ops.render = render // jsx最终会被编译成h('xxx'), jsx是靠babel做的编译，有个插件plugin。？？？\n            }\n        }\n        // （2）如果有render函数，直接赋值render到vm.$options上\n        ops.render // 最终可以获取render方法\n\n\n        console.log('render', ops.render)\n        // ƒ anonymous(\n        //     ) {\n        //     with(this){return _c('div',{id:\"app\"},_c('div',{style:{\"color\":\" red\",\"background\":\" pink\"}},_v(_s(name)+\"hello\"+_s(age))),_c('span',null,_v(_s(age))))}\n        //     }\n\n        // 7-3 初步渲染 调用render方法\n        // 把当前的vm实例上的render调用一下，产生虚拟dom，再把虚拟dom渲染到el中去\n        mountComponent(vm, el); // 组件的挂载，挂载实例，实例里有render方法，挂载到元素el上\n\n        // script 标签引用的vue.global.js 这个编译过程是在浏览器运行的\n        // runtime运行时是不包含模版编译的，整个编译时打包的时候通过loader来转义.vue文件的。用runtime的时候不能使用模版（指的是template: '<div>hello</div>'属性）\n    }\n\n} \n\n","// class类是将所有的方法都耦合在一起不好维护\n// vue通过构造函数的方式，在其构造函数prototype上去添加方法，可以在多个文件去操作\n\nimport { initMixin } from \"./init\"\nimport { lifecycle } from \"./lifecycle\"\nimport { nexTick } from \"./observe/watcher\"\n\nfunction Vue(options) { // options就是用户的选项\n    this._init(options) // 默认就调用了init\n}\n\n// 11节课实现异步更新时扩展的方法\nVue.prototype.$nextTick = nexTick\n\n// 把原型方法扩展成一个个函数\ninitMixin(Vue) // 扩展了init方法\n\n// 接入lifecycle.js\nlifecycle(Vue) // 扩展lifecycle方法\n\nexport default Vue"],"names":["id","Dep","constructor","console","log","subs","depend","target","addDep","addSub","watcher","push","notify","forEach","update","stack","pushTarget","popTarget","pop","length","oldArrayProto","Array","prototype","newArrayProto","Object","create","methods","method","args","result","call","ob","__ob__","inserted","slice","observeArray","dep","observe","data","Observer","defineProperty","value","enumerable","isArray","__proto__","walk","keys","key","defineReactive","item","dependArray","i","current","childOb","get","set","newValue","Watcher","vm","fn","options","renderWatcher","getter","deps","depsId","Set","lazy","dirty","undefined","has","add","evaluate","queueWatcher","run","queue","pending","flushSchedulerQueue","flushQueue","q","setTimeout","callbacks","waiting","flushCallbacks","cbs","cb","nexTick","Promise","resolve","then","initState","opts","$options","initData","computed","initComputed","_data","proxy","watchers","_computedWatchers","userDef","defineComputed","setter","createComputedGetter","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","ELEMENT_TYPE","TEXT_TYPE","currentParent","root","createASTElement","tag","attrs","type","children","parent","start","node","chars","text","replace","end","advance","n","substring","parseStartTag","match","tagName","attr","name","textEnd","indexOf","startTagMatch","endTagMatch","defaultTagRE","genProps","str","obj","split","JSON","stringify","gen","codegen","test","tokens","lastIndex","exec","index","trim","join","genChildren","map","child","ast","code","compileToFunction","template","render","Function","createElementVNode","vnode","createTextVNode","createElm","el","document","createElement","patchProps","appendChild","createTextNode","props","styleName","style","setAttribute","patch","oldVNode","isRealElement","nodeType","elm","parentElm","parentNode","newElm","insertBefore","nextSibling","removeChild","lifecycle","Vue","_update","$el","_c","arguments","_v","_s","_render","mountComponent","updateComponent","initMixin","_init","$mount","querySelector","ops","outerHTML","$nextTick"],"mappings":"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"}